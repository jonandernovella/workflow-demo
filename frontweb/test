BASH=/bin/bash
BASHOPTS=checkwinsize:cmdhist:complete_fullquote:expand_aliases:extglob:extquote:force_fignore:histappend:interactive_comments:progcomp:promptvars:sourcepath
BASH_ALIASES=()
BASH_ARGC=()
BASH_ARGV=()
BASH_CMDS=()
BASH_COMPLETION_COMPAT_DIR=/etc/bash_completion.d
BASH_LINENO=()
BASH_REMATCH=()
BASH_SOURCE=()
BASH_VERSINFO=([0]="4" [1]="3" [2]="11" [3]="1" [4]="release" [5]="x86_64-pc-linux-gnu")
BASH_VERSION='4.3.11(1)-release'
COLORTERM=gnome-terminal
COLUMNS=134
COMP_WORDBREAKS=$' \t\n"\'><;|&(:'
DBUS_SESSION_BUS_ADDRESS=unix:abstract=/tmp/dbus-49Ai7VjId1
DEFAULTS_PATH=/usr/share/gconf/xfce.default.path
DESKTOP_SESSION=xfce
DIRSTACK=()
DISPLAY=:0.0
EUID=1000
GDMSESSION=xfce
GDM_XSERVER_LOCATION=local
GLADE_CATALOG_PATH=:
GLADE_MODULE_PATH=:
GLADE_PIXMAP_PATH=:
GNOME_KEYRING_CONTROL=/run/user/1000/keyring-8fdEdx
GNOME_KEYRING_PID=
GPG_AGENT_INFO=/run/user/1000/keyring-8fdEdx/gpg:0:1
GROUPS=()
HISTCONTROL=ignoreboth
HISTFILE=/home/anders/.bash_history
HISTFILESIZE=9999999
HISTIGNORE='ls:&:[bf]g:exit'
HISTSIZE=9999
HISTTIMEFORMAT='%F '
HOME=/home/anders
HOSTNAME=lilldatorn
HOSTTYPE=x86_64
IFS=$' \t\n'
IM_CONFIG_PHASE=1
INSTANCE=
JOB=dbus
LANG=en_US.UTF-8
LC_ADDRESS=sv_SE.utf8
LC_COLLATE=sv_SE.utf8
LC_IDENTIFICATION=sv_SE.utf8
LC_MEASUREMENT=sv_SE.utf8
LC_MONETARY=sv_SE.utf8
LC_NAME=sv_SE.utf8
LC_NUMERIC=en_US.utf8
LC_PAPER=sv_SE.utf8
LC_TELEPHONE=sv_SE.utf8
LC_TIME=sv_SE.utf8
LD_LIBRARY_PATH=/home/anders/lib:
LESSCLOSE='/usr/bin/lesspipe %s %s'
LESSOPEN='| /usr/bin/lesspipe %s'
LINES=24
LOGNAME=anders
LS_COLORS='rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lz=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.axa=00;36:*.oga=00;36:*.spx=00;36:*.xspf=00;36:'
M2=/bin
MACHTYPE=x86_64-pc-linux-gnu
MAILCHECK=60
MANDATORY_PATH=/usr/share/gconf/xfce.mandatory.path
MAVEN_OPTS='-Xms256m -Xmx512m'
MDMSESSION=xfce
MDM_LANG=en_US.UTF-8
MDM_XSERVER_LOCATION=local
NEMO_SCRIPT_CURRENT_URI=file:///home/anders/projekt/docker/nginx
NEMO_SCRIPT_NEXT_PANE_CURRENT_URI=
NEMO_SCRIPT_NEXT_PANE_SELECTED_FILE_PATHS=
NEMO_SCRIPT_NEXT_PANE_SELECTED_URIS=
NEMO_SCRIPT_SELECTED_FILE_PATHS=
NEMO_SCRIPT_SELECTED_URIS=
NEMO_SCRIPT_WINDOW_GEOMETRY=1048x780+432+121
OLDPWD=/home/anders/projekt
OPTERR=1
OPTIND=1
OSTYPE=linux-gnu
PATH=/home/anders/projekt/maven/scripts/target:/home/anders/program:/home/anders/program/ncbi-blast-2.2.27+/bin:/home/anders/program/BEASTv1.8.0/bin:/home/anders/program/staden-2.0.0b9.x86_64/bin:/home/anders/program/staden-2.0.0b9.x86_64/bin:/home/anders/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/opt/bin:/home/anders/program/terraform
PHRED_PARAMETER_FILE=/home/anders/settings/phredpar.dat
PIPESTATUS=([0]="0")
PPID=4019
PROMPT_COMMAND='history -a'
PS1='\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
PS2='> '
PS4='+ '
PWD=/home/anders/projekt/phenomenal/workflow-demo/frontweb
SELINUX_INIT=YES
SESSION=xfce
SESSIONTYPE=
SESSION_MANAGER=local/lilldatorn:@/tmp/.ICE-unix/1921,unix/lilldatorn:/tmp/.ICE-unix/1921
SHELL=/bin/bash
SHELLOPTS=braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor
SHLVL=2
SSH_AGENT_PID=1936
SSH_AUTH_SOCK=/tmp/ssh-8N1M8sXbuhyZ/agent.1935
TERM=xterm
TEXTDOMAIN=im-config
TEXTDOMAINDIR=/usr/share/locale/
UID=1000
UPSTART_EVENTS='started xsession'
UPSTART_INSTANCE=
UPSTART_JOB=startxfce4
UPSTART_SESSION=unix:abstract=/com/ubuntu/upstart-session/1000/1667
USER=anders
USERNAME=anders
VBOX_USER_HOME=/opt/.VirtualBox
VTE_VERSION=3409
WINDOWID=69206398
WINDOWPATH=8
XAUTHORITY=/home/anders/.Xauthority
XDG_CONFIG_DIRS=/etc/xdg/xdg-xfce:/usr/share/upstart/xdg:/etc/xdg:/etc/xdg
XDG_CURRENT_DESKTOP=XFCE
XDG_DATA_DIRS=/usr/share/xfce:/usr/share/xfce4:/usr/local/share/:/usr/share/:/usr/share/mdm/:/usr/share
XDG_MENU_PREFIX=xfce-
XDG_RUNTIME_DIR=/run/user/1000
XDG_SEAT=seat0
XDG_SESSION_COOKIE=d0b365466cafa890343c40f300000003-1456307752.185140-1879995049
XDG_SESSION_DESKTOP=xfce
XDG_SESSION_ID=c1
XDG_VTNR=8
_=farmbio/frontweb
__git_printf_supports_v=yes
__grub_script_check_program=grub-script-check
__mvnall_plugin_and_goals=$'clean:clean\n\t clean:help\n\t compiler:compile\n\t compiler:testCompile\n\t compiler:help\n\t deploy:deploy\n\t deploy:deploy-file\n\t deploy:help\n\t install:install\n\t install:install-file\n\t install:help\n\t resources:resources\n\t resources:testResources\n\t resources:copy-resources\n\t resources:help\n\t site:site\n\t site:deploy\n\t site:run\n\t site:stage\n\t site:stage-deploy\n\t site:attach-descriptor\n\t site:jar\n\t site:help\n\t surefire:test\n\t surefire:help\n\t verifier:verify\n\t verifier:help ear:ear\n\t ear:generate-application-xml\n\t ear:help\n\t jar:jar\n\t jar:test-jar\n\t jar:sign\n\t jar:sign-verify\n\t jar:help\n\t rar:rar\n\t rar:help\n\t war:war\n\t war:exploded\n\t war:inplace\n\t war:manifest\n\t war:help\n\t shade:shade\n\t shade:help changelog:changelog\n\t changelog:dev-activity\n\t changelog:file-activity\n\t changelog:help\n\t changes:announcement-mail\n\t changes:announcement-generate\n\t changes:changes-report\n\t changes:jira-report\n\t changes:changes-validate\n\t changes:help\n\t checkstyle:checkstyle\n\t checkstyle:check\n\t checkstyle:help\n\t doap:generate\n\t doap:help\n\t docck:check\n\t docck:help\n\t javadoc:javadoc\n\t javadoc:test-javadoc\n\t javadoc:aggregate\n\t javadoc:test-aggregate\n\t javadoc:jar\n\t javadoc:test-jar\n\t javadoc:help\n\t jxr:jxr\n\t jxr:test-jxr\n\t jxr:help\n\t pmd:pmd\n\t pmd:cpd\n\t pmd:check\n\t pmd:cpd-check\n\t pmd:help\n\t project-info-reports:cim\n\t project-info-reports:dependencies\n\t project-info-reports:dependency-convergence\n\t project-info-reports:dependency-management\n\t project-info-reports:index\n\t project-info-reports:issue-tracking\n\t project-info-reports:license\n\t project-info-reports:mailing-list\n\t project-info-reports:plugin-management\n\t project-info-reports:project-team\n\t project-info-reports:scm\n\t project-info-reports:summary\n\t project-info-reports:help\n\t surefire-report:report\n\t surefire-report:report-only\n\t surefire-report:help ant:ant\n\t ant:clean\n\t ant:help\n\t antrun:run\n\t antrun:help\n\t archetype:create\n\t archetype:generate\n\t archetype:create-from-project\n\t archetype:crawl\n\t archetype:help\n\t assembly:assembly\n\t assembly:directory\n\t assembly:directory-single\n\t assembly:single\n\t assembly:help\n\t dependency:copy\n\t dependency:copy-dependencies\n\t dependency:unpack\n\t dependency:unpack-dependencies\n\t dependency:resolve\n\t dependency:list\n\t dependency:sources\n\t dependency:resolve-plugins\n\t dependency:go-offline\n\t dependency:purge-local-repository\n\t dependency:build-classpath\n\t dependency:analyze\n\t dependency:analyze-dep-mgt\n\t dependency:tree\n\t dependency:help\n\t enforcer:enforce\n\t enforcer:display-info\n\t enforcer:help\n\t gpg:sign\n\t gpg:sign-and-deploy-file\n\t gpg:help\n\t help:active-profiles\n\t help:all-profiles\n\t help:describe\n\t help:effective-pom\n\t help:effective-settings\n\t help:evaluate\n\t help:expressions\n\t help:system\n\t invoker:install\n\t invoker:run\n\t invoker:help\n\t one:convert\n\t one:deploy-maven-one-repository\n\t one:install-maven-one-repository\n\t one:maven-one-plugin\n\t one:help\n\t patch:apply\n\t patch:help\n\t pdf:pdf\n\t pdf:help\n\t plugin:descriptor\n\t plugin:report\n\t plugin:updateRegistry\n\t plugin:xdoc\n\t plugin:addPluginArtifactMetadata\n\t plugin:helpmojo\n\t plugin:help\n\t release:clean\n\t release:prepare\n\t release:rollback\n\t release:perform\n\t release:stage\n\t release:branch\n\t release:help\n\t reactor:resume\n\t reactor:make\n\t reactor:make-dependents\n\t reactor:make-scm-changes\n\t reactor:help\n\t remote-resources:bundle\n\t remote-resources:process\n\t remote-resources:help\n\t repository:bundle-create\n\t repository:bundle-pack\n\t repository:help\n\t scm:branch\n\t scm:validate\n\t scm:add\n\t scm:unedit\n\t scm:export\n\t scm:bootstrap\n\t scm:changelog\n\t scm:list\n\t scm:checkin\n\t scm:checkout\n\t scm:status\n\t scm:update\n\t scm:diff\n\t scm:update-subprojects\n\t scm:edit\n\t scm:tag\n\t scm:help\n\t source:aggregate\n\t source:jar\n\t source:test-jar\n\t source:jar-no-fork\n\t source:test-jar-no-fork\n\t source:help\n\t stage:copy\n\t stage:help \n  eclipse:clean\n\t eclipse:configure-workspace\n\t eclipse:eclipse\n\t eclipse:help\n\t eclipse:install-plugins\n\t eclipse:m2eclipse\n\t eclipse:make-artifacts\n\t eclipse:myeclipse\n\t eclipse:myeclipse-clean\n\t eclipse:rad\n\t eclipse:rad-clean\n\t eclipse:remove-cache\n\t eclipse:to-maven\n\t idea:clean\n\t idea:help\n\t idea:idea\n\t idea:module\n\t idea:project\n\t idea:workspace \n\t plexus:app plexus:bundle-application plexus:bundle-runtime plexus:descriptor plexus:runtime plexus:service\n\t jetty:run-war jetty:run\n\t cargo:start cargo:stop\n\t dbunit:export dbunit:operation\n\t hibernate3:hbm2cfgxml hibernate3:hbm2ddl hibernate3:hbm2doc hibernate3:hbm2hbmxml hibernate3:hbm2java hibernate3:schema-export\n\t   hibernate3:schema-update\n\t groovy:compile groovy:console groovy:execute groovy:generateStubs groovy:generateTestStubs groovy:help groovy:providers groovy:shell\n\t   groovy:testCompile\n\t gwt:compile gwt:eclipse gwt:eclipseTest gwt:generateAsync gwt:help gwt:i18n gwt:test\n\t javacc:help javacc:javacc javacc:jjdoc javacc:jjtree javacc:jjtree-javacc javacc:jtb javacc:jtb-javacc\n\t jboss:configure jboss:deploy jboss:harddeploy jboss:start jboss:stop jboss:undeploy\n\t jboss-packaging:esb jboss-packaging:esb-exploded jboss-packaging:har jboss-packaging:har-exploded jboss-packaging:sar jboss-packaging:sar-exploded\n\t   jboss-packaging:sar-inplace jboss-packaging:spring\n\t jpox:enhance jpox:schema-create jpox:schema-dbinfo jpox:schema-delete jpox:schema-info jpox:schema-validate\n\t make:autoreconf make:chmod make:chown make:compile make:configure make:help make:make-clean make:make-dist make:make-install make:test\n\t   make:validate-pom\n\t nbm:autoupdate nbm:branding nbm:cluster nbm:directory nbm:jar nbm:nbm nbm:populate-repository nbm:run-ide nbm:run-platform\n\t tomcat:deploy tomcat:exploded tomcat:info tomcat:inplace tomcat:list tomcat:redeploy tomcat:resources tomcat:roles tomcat:run tomcat:run-war\n\t   tomcat:sessions tomcat:start tomcat:stop tomcat:undeploy\n\t wagon:copy wagon:download wagon:download-single wagon:help wagon:list wagon:merge-maven-repos wagon:upload wagon:upload-single\n\t was6:clean was6:ejbdeploy was6:help was6:installApp was6:wsAdmin was6:wsDefaultBindings was6:wsListApps was6:wsStartApp was6:wsStartServer\n\t   was6:wsStopApp was6:wsStopServer was6:wsUninstallApp\n\t weblogic:appc weblogic:clientgen weblogic:clientgen9 weblogic:deploy weblogic:jwsc weblogic:listapps weblogic:redeploy weblogic:servicegen\n\t   weblogic:start weblogic:stop weblogic:undeploy weblogic:wsdlgen '
__mvnclassifiers='sources test-jar'
__mvnclean_phases=$'pre-clean\n\t clean\n\t post-clean'
__mvncore_plugins=$'clean:clean\n\t clean:help\n\t compiler:compile\n\t compiler:testCompile\n\t compiler:help\n\t deploy:deploy\n\t deploy:deploy-file\n\t deploy:help\n\t install:install\n\t install:install-file\n\t install:help\n\t resources:resources\n\t resources:testResources\n\t resources:copy-resources\n\t resources:help\n\t site:site\n\t site:deploy\n\t site:run\n\t site:stage\n\t site:stage-deploy\n\t site:attach-descriptor\n\t site:jar\n\t site:help\n\t surefire:test\n\t surefire:help\n\t verifier:verify\n\t verifier:help'
__mvncustom_plugins=
__mvndefault_phases=$'validate \n\t initialize \n\t generate-sources \n\t process-sources \n\t generate-resources \n\t process-resources \n\t compile \n\t process-classes \n\t generate-test-sources \n\t process-test-sources \n\t generate-test-resources \n\t process-test-resources \n\t test-compile \n\t process-test-classes \n\t test \n\t package \n\t pre-integration-test \n\t integration-test \n\t post-integration-test \n\t verify \n\t install \n\t deploy'
__mvnide_plugins=$'eclipse:clean\n\t eclipse:configure-workspace\n\t eclipse:eclipse\n\t eclipse:help\n\t eclipse:install-plugins\n\t eclipse:m2eclipse\n\t eclipse:make-artifacts\n\t eclipse:myeclipse\n\t eclipse:myeclipse-clean\n\t eclipse:rad\n\t eclipse:rad-clean\n\t eclipse:remove-cache\n\t eclipse:to-maven\n\t idea:clean\n\t idea:help\n\t idea:idea\n\t idea:module\n\t idea:project\n\t idea:workspace'
__mvnopts=$'--also-make --also-make-dependents --file --debug --batch-mode --lax-checksums --strict-checksums --check-plugin-updates --define \n  --errors --encrypt-master-password --encrypt-password --fail-at-end --fail-fast --fail-never --help --non-recursive --no-plugin-registry \n  --no-plugin-updates --offline --activate-profiles --projects --quiet --reactor --resume-from --settings --global-settings --update-snapshots \n  --update-plugins --version --show-version'
__mvnoptsWithArg='--file|--define|--encrypt-master-password|--encrypt-password|--resume-from|--settings|--global-settings|--activate-profiles|--projects'
__mvnother_plugins=$'\n\t plexus:app plexus:bundle-application plexus:bundle-runtime plexus:descriptor plexus:runtime plexus:service\n\t jetty:run-war jetty:run\n\t cargo:start cargo:stop\n\t dbunit:export dbunit:operation\n\t hibernate3:hbm2cfgxml hibernate3:hbm2ddl hibernate3:hbm2doc hibernate3:hbm2hbmxml hibernate3:hbm2java hibernate3:schema-export\n\t   hibernate3:schema-update\n\t groovy:compile groovy:console groovy:execute groovy:generateStubs groovy:generateTestStubs groovy:help groovy:providers groovy:shell\n\t   groovy:testCompile\n\t gwt:compile gwt:eclipse gwt:eclipseTest gwt:generateAsync gwt:help gwt:i18n gwt:test\n\t javacc:help javacc:javacc javacc:jjdoc javacc:jjtree javacc:jjtree-javacc javacc:jtb javacc:jtb-javacc\n\t jboss:configure jboss:deploy jboss:harddeploy jboss:start jboss:stop jboss:undeploy\n\t jboss-packaging:esb jboss-packaging:esb-exploded jboss-packaging:har jboss-packaging:har-exploded jboss-packaging:sar jboss-packaging:sar-exploded\n\t   jboss-packaging:sar-inplace jboss-packaging:spring\n\t jpox:enhance jpox:schema-create jpox:schema-dbinfo jpox:schema-delete jpox:schema-info jpox:schema-validate\n\t make:autoreconf make:chmod make:chown make:compile make:configure make:help make:make-clean make:make-dist make:make-install make:test\n\t   make:validate-pom\n\t nbm:autoupdate nbm:branding nbm:cluster nbm:directory nbm:jar nbm:nbm nbm:populate-repository nbm:run-ide nbm:run-platform\n\t tomcat:deploy tomcat:exploded tomcat:info tomcat:inplace tomcat:list tomcat:redeploy tomcat:resources tomcat:roles tomcat:run tomcat:run-war\n\t   tomcat:sessions tomcat:start tomcat:stop tomcat:undeploy\n\t wagon:copy wagon:download wagon:download-single wagon:help wagon:list wagon:merge-maven-repos wagon:upload wagon:upload-single\n\t was6:clean was6:ejbdeploy was6:help was6:installApp was6:wsAdmin was6:wsDefaultBindings was6:wsListApps was6:wsStartApp was6:wsStartServer\n\t   was6:wsStopApp was6:wsStopServer was6:wsUninstallApp\n\t weblogic:appc weblogic:clientgen weblogic:clientgen9 weblogic:deploy weblogic:jwsc weblogic:listapps weblogic:redeploy weblogic:servicegen\n\t   weblogic:start weblogic:stop weblogic:undeploy weblogic:wsdlgen'
__mvnpackaging='pom jar maven-plugin ejb war ear rar par'
__mvnpackaging_plugins=$'ear:ear\n\t ear:generate-application-xml\n\t ear:help\n\t jar:jar\n\t jar:test-jar\n\t jar:sign\n\t jar:sign-verify\n\t jar:help\n\t rar:rar\n\t rar:help\n\t war:war\n\t war:exploded\n\t war:inplace\n\t war:manifest\n\t war:help\n\t shade:shade\n\t shade:help'
__mvnparams=$'-Dmaven.test.skip=true -Dsurefire.useFile=false -Dmaven.surefire.debug -Xdebug -Xnoagent -Djava.compiler=NONE \n  -Xrunjdwp:transport=dt_socket,address=5005,server=y,suspend=y -Dverbose -Dmaven.test.failure.ignore=true'
__mvnphases=$'validate \n\t initialize \n\t generate-sources \n\t process-sources \n\t generate-resources \n\t process-resources \n\t compile \n\t process-classes \n\t generate-test-sources \n\t process-test-sources \n\t generate-test-resources \n\t process-test-resources \n\t test-compile \n\t process-test-classes \n\t test \n\t package \n\t pre-integration-test \n\t integration-test \n\t post-integration-test \n\t verify \n\t install \n\t deploy pre-clean\n\t clean\n\t post-clean pre-site\n\t site\n\t post-site\n\t site-deploy'
__mvnplugins=$'\n ant:\n antrun:\n archetype:\n aembly:\n cargo:\n changelog:\n change:\n checktyle:\n clean:\nclean:\n compiler:\n dbunit:\n dependency:\n deploy:\n doap:\n docck:\n ear:\n eclipe:\n enforcer:\n gpg:\n groovy:\n gwt:\n help:\n hibernate3:\n idea:\n intall:\n invoker:\n jar:\n javacc:\n javadoc:\n jbo:\n jbo-packaging:\n jetty:\n jpox:\n jxr:\n make:\n nbm:\n one:\n patch:\n pdf:\n plexu:\n plugin:\n pmd:\n project-info-report:\n rar:\n reactor:\n releae:\n remote-reource:\n repoitory:\n reource:\n cm:\n hade:\n ite:\n ource:\n tage:\n urefire:\n urefire-report:\n tomcat:\n wagon:\n war:\n wa6:\n weblogic:\n verifier:'
__mvnreporting_plugins=$'changelog:changelog\n\t changelog:dev-activity\n\t changelog:file-activity\n\t changelog:help\n\t changes:announcement-mail\n\t changes:announcement-generate\n\t changes:changes-report\n\t changes:jira-report\n\t changes:changes-validate\n\t changes:help\n\t checkstyle:checkstyle\n\t checkstyle:check\n\t checkstyle:help\n\t doap:generate\n\t doap:help\n\t docck:check\n\t docck:help\n\t javadoc:javadoc\n\t javadoc:test-javadoc\n\t javadoc:aggregate\n\t javadoc:test-aggregate\n\t javadoc:jar\n\t javadoc:test-jar\n\t javadoc:help\n\t jxr:jxr\n\t jxr:test-jxr\n\t jxr:help\n\t pmd:pmd\n\t pmd:cpd\n\t pmd:check\n\t pmd:cpd-check\n\t pmd:help\n\t project-info-reports:cim\n\t project-info-reports:dependencies\n\t project-info-reports:dependency-convergence\n\t project-info-reports:dependency-management\n\t project-info-reports:index\n\t project-info-reports:issue-tracking\n\t project-info-reports:license\n\t project-info-reports:mailing-list\n\t project-info-reports:plugin-management\n\t project-info-reports:project-team\n\t project-info-reports:scm\n\t project-info-reports:summary\n\t project-info-reports:help\n\t surefire-report:report\n\t surefire-report:report-only\n\t surefire-report:help'
__mvnsite_phases=$'pre-site\n\t site\n\t post-site\n\t site-deploy'
__mvntools_plugins=$'ant:ant\n\t ant:clean\n\t ant:help\n\t antrun:run\n\t antrun:help\n\t archetype:create\n\t archetype:generate\n\t archetype:create-from-project\n\t archetype:crawl\n\t archetype:help\n\t assembly:assembly\n\t assembly:directory\n\t assembly:directory-single\n\t assembly:single\n\t assembly:help\n\t dependency:copy\n\t dependency:copy-dependencies\n\t dependency:unpack\n\t dependency:unpack-dependencies\n\t dependency:resolve\n\t dependency:list\n\t dependency:sources\n\t dependency:resolve-plugins\n\t dependency:go-offline\n\t dependency:purge-local-repository\n\t dependency:build-classpath\n\t dependency:analyze\n\t dependency:analyze-dep-mgt\n\t dependency:tree\n\t dependency:help\n\t enforcer:enforce\n\t enforcer:display-info\n\t enforcer:help\n\t gpg:sign\n\t gpg:sign-and-deploy-file\n\t gpg:help\n\t help:active-profiles\n\t help:all-profiles\n\t help:describe\n\t help:effective-pom\n\t help:effective-settings\n\t help:evaluate\n\t help:expressions\n\t help:system\n\t invoker:install\n\t invoker:run\n\t invoker:help\n\t one:convert\n\t one:deploy-maven-one-repository\n\t one:install-maven-one-repository\n\t one:maven-one-plugin\n\t one:help\n\t patch:apply\n\t patch:help\n\t pdf:pdf\n\t pdf:help\n\t plugin:descriptor\n\t plugin:report\n\t plugin:updateRegistry\n\t plugin:xdoc\n\t plugin:addPluginArtifactMetadata\n\t plugin:helpmojo\n\t plugin:help\n\t release:clean\n\t release:prepare\n\t release:rollback\n\t release:perform\n\t release:stage\n\t release:branch\n\t release:help\n\t reactor:resume\n\t reactor:make\n\t reactor:make-dependents\n\t reactor:make-scm-changes\n\t reactor:help\n\t remote-resources:bundle\n\t remote-resources:process\n\t remote-resources:help\n\t repository:bundle-create\n\t repository:bundle-pack\n\t repository:help\n\t scm:branch\n\t scm:validate\n\t scm:add\n\t scm:unedit\n\t scm:export\n\t scm:bootstrap\n\t scm:changelog\n\t scm:list\n\t scm:checkin\n\t scm:checkout\n\t scm:status\n\t scm:update\n\t scm:diff\n\t scm:update-subprojects\n\t scm:edit\n\t scm:tag\n\t scm:help\n\t source:aggregate\n\t source:jar\n\t source:test-jar\n\t source:jar-no-fork\n\t source:test-jar-no-fork\n\t source:help\n\t stage:copy\n\t stage:help'
_backup_glob='@(#*#|*@(~|.@(bak|orig|rej|swp|dpkg*|rpm@(orig|new|save))))'
_xspecs=([freeamp]="!*.@(mp3|og[ag]|pls|m3u)" [cdiff]="!*.@(dif?(f)|?(d)patch)?(.@([gx]z|bz2|lzma))" [bibtex]="!*.aux" [rgview]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [oowriter]="!*.@(sxw|stw|sxg|sgl|doc?([mx])|dot?([mx])|rtf|txt|htm|html|?(f)odt|ott|odm)" [chromium-browser]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [tex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [zathura]="!*.@(cb[rz7t]|djv?(u)|?(e)ps|pdf)" [netscape]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [acroread]="!*.[pf]df" [makeinfo]="!*.texi*" [kwrite]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [gview]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [qiv]="!*.@(gif|jp?(e)g|tif?(f)|png|p[bgp]m|bmp|x[bp]m|rle|rgb|pcx|fits|pm|svg)" [lrunzip]="!*.lrz" [bzcat]="!*.?(t)bz?(2)" [amaya]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [pdftex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [hbpp]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [rpm2cpio]="!*.[rs]pm" [view]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [unxz]="!*.@(?(t)xz|tlz|lzma)" [ly2dvi]="!*.ly" [mozilla]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [modplugplay]="!*.@(669|abc|am[fs]|d[bs]m|dmf|far|it|mdl|m[eo]d|mid?(i)|mt[2m]|okta|p[st]m|s[3t]m|ult|umx|wav|xm)" [lzgrep]="!*.@(tlz|lzma)" [pyflakes]="!*.py" [dillo]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [aaxine]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.part)" [dvipdfmx]="!*.dvi" [advi]="!*.dvi" [ggv]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [lzmore]="!*.@(tlz|lzma)" [lzless]="!*.@(tlz|lzma)" [kdvi]="!*.@(dvi|DVI)?(.@(gz|Z|bz2))" [poedit]="!*.po" [firefox]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [gv]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [madplay]="!*.mp3" [lbzcat]="!*.?(t)bz?(2)" [lilypond]="!*.ly" [gtranslator]="!*.po" [jadetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [sxemacs]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [epdfview]="!*.pdf" [gpdf]="!*.[pf]df" [kghostview]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [pbzcat]="!*.?(t)bz?(2)" [texi2dvi]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [ps2pdf12]="!*.@(?(e)ps|pdf)" [ee]="!*.@(gif|jp?(e)g|miff|tif?(f)|pn[gm]|p[bgp]m|bmp|xpm|ico|xwd|tga|pcx)" [lzcat]="!*.@(tlz|lzma)" [lbunzip2]="!*.?(t)bz?(2)" [ps2pdf13]="!*.@(?(e)ps|pdf)" [vim]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [ps2pdf14]="!*.@(?(e)ps|pdf)" [dvips]="!*.dvi" [lzfgrep]="!*.@(tlz|lzma)" [hbrun]="!*.[Hh][Rr][Bb]" [kbabel]="!*.po" [rview]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [kaffeine]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM|iso|ISO)|+([0-9]).@(vdr|VDR))?(.part)" [xv]="!*.@(gif|jp?(e)g|tif?(f)|png|p[bgp]m|bmp|x[bp]m|rle|rgb|pcx|fits|pm|?(e)ps)" [rgvim]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [dvitype]="!*.dvi" [oodraw]="!*.@(sxd|std|sda|sdd|?(f)odg|otg)" [elinks]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [playmidi]="!*.@(mid?(i)|cmf)" [realplay]="!*.@(rm?(j)|ra?(m)|smi?(l))" [xine]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.part)" [xpdf]="!*.@(pdf|fdf)?(.@(gz|xz|Z|bz2))" [gqmpeg]="!*.@(mp3|og[ag]|pls|m3u)" [lzegrep]="!*.@(tlz|lzma)" [aviplay]="!*.@(avi|asf|wmv)" [latex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [rvim]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [bunzip2]="!*.?(t)bz?(2)" [ogg123]="!*.@(og[ag]|m3u|flac|spx)" [ps2pdfwr]="!*.@(?(e)ps|pdf)" [znew]="*.Z" [harbour]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [lokalize]="!*.po" [kate]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [xemacs]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [dragon]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM|iso|ISO)|+([0-9]).@(vdr|VDR))?(.part)" [unlzma]="!*.@(tlz|lzma)" [pdflatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [vi]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [mozilla-firefox]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [ooimpress]="!*.@(sxi|sti|pps?(x)|ppt?([mx])|pot?([mx])|?(f)odp|otp)" [gvim]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [uncompress]="!*.Z" [kid3-qt]="!*.@(mp[234c]|og[ag]|@(fl|a)ac|m4[abp]|spx|tta|w?(a)v|wma|aif?(f)|asf|ape)" [xanim]="!*.@(mpg|mpeg|avi|mov|qt)" [unpigz]="!*.@(Z|[gGd]z|t[ag]z)" [portecle]="!@(*.@(ks|jks|jceks|p12|pfx|bks|ubr|gkr|cer|crt|cert|p7b|pkipath|pem|p10|csr|crl)|cacerts)" [oocalc]="!*.@(sxc|stc|xls?([bmx])|xlw|xlt?([mx])|[ct]sv|?(f)ods|ots)" [emacs]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [fbxine]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.part)" [lynx]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [ps2pdf]="!*.@(?(e)ps|pdf)" [kpdf]="!*.@(?(e)ps|pdf)" [oomath]="!*.@(sxm|smf|mml|odf)" [compress]="*.Z" [iceweasel]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [mpg321]="!*.mp3" [mpg123]="!*.mp3" [zcat]="!*.@(Z|[gGd]z|t[ag]z)" [unzip]="!*.@(zip|[ejsw]ar|exe|pk3|wsz|zargo|xpi|s[tx][cdiw]|sx[gm]|o[dt][tspgfc]|od[bm]|oxt|epub|apk|do[ct][xm]|p[op]t[mx]|xl[st][xm])" [pbunzip2]="!*.?(t)bz?(2)" [kid3]="!*.@(mp[234c]|og[ag]|@(fl|a)ac|m4[abp]|spx|tta|w?(a)v|wma|aif?(f)|asf|ape)" [pdfjadetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [dvipdf]="!*.dvi" [gharbour]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [modplug123]="!*.@(669|abc|am[fs]|d[bs]m|dmf|far|it|mdl|m[eo]d|mid?(i)|mt[2m]|okta|p[st]m|s[3t]m|ult|umx|wav|xm)" [dvipdfm]="!*.dvi" [oobase]="!*.odb" [texi2html]="!*.texi*" [zipinfo]="!*.@(zip|[ejsw]ar|exe|pk3|wsz|zargo|xpi|s[tx][cdiw]|sx[gm]|o[dt][tspgfc]|od[bm]|oxt|epub|apk|do[ct][xm]|p[op]t[mx]|xl[st][xm])" [epiphany]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [gunzip]="!*.@(Z|[gGd]z|t[ag]z)" [google-chrome]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [okular]="!*.@(okular|@(?(e|x)ps|?(E|X)PS|[pf]df|[PF]DF|dvi|DVI|cb[rz]|CB[RZ]|djv?(u)|DJV?(U)|dvi|DVI|gif|jp?(e)g|miff|tif?(f)|pn[gm]|p[bgp]m|bmp|xpm|ico|xwd|tga|pcx|GIF|JP?(E)G|MIFF|TIF?(F)|PN[GM]|P[BGP]M|BMP|XPM|ICO|XWD|TGA|PCX|epub|EPUB|odt|ODT|fb?(2)|FB?(2)|mobi|MOBI|g3|G3|chm|CHM)?(.?(gz|GZ|bz2|BZ2)))" [slitex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [galeon]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [bzme]="!*.@(zip|z|gz|tgz)" [xfig]="!*.fig" [xzcat]="!*.@(?(t)xz|tlz|lzma)" [timidity]="!*.@(mid?(i)|rmi|rcp|[gr]36|g18|mod|xm|it|x3m|s[3t]m|kar)" [dviselect]="!*.dvi" [xdvi]="!*.@(dvi|DVI)?(.@(gz|Z|bz2))" )
arg=ng
_R () 
{ 
    local cur loneOpts helpOpts stdOpts argOpts versOpts cmds cmd furtherOpts;
    local fileNames dirNames i lastToken;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    loneOpts='--version RHOME';
    versOpts='-v --version';
    helpOpts='-h --help';
    stdOpts='--save --no-save --no-environ --no-site-file            \
    --no-init-file --restore --no-restore-data --no-restore-history  \
    --no-restore --vanilla --no-readline -q --quiet --silent --slave \
    --interactive --verbose -d -g --args -f -e';
    argOpts='--min-vsize --max-vsize --min-nsize --max-nsize \
    --encoding --max-ppsize --debugger --debugger-args \
    --gui --arch --file';
    cmds='BATCH COMPILE SHLIB INSTALL REMOVE build check LINK Rprof \
    Rdconv Rd2pdf Rd2txt Stangle Sweave Rdiff config javareconf rtags';
    fileNames='';
    dirNames='';
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "CMD $loneOpts $helpOpts $stdOpts" -- $cur ) $( compgen -o nospace -W "$argOpts" -- $cur ));
        return 0;
    fi;
    if [[ ${COMP_WORDS[$COMP_CWORD-1]} == @(-v|--version|RHOME|-h|--help) ]]; then
        return 0;
    fi;
    lastToken=${COMP_WORDS[$COMP_CWORD-1]};
    if [[ ${COMP_WORDS[1]} == "CMD" ]]; then
        if [[ $COMP_CWORD -eq 2 ]]; then
            COMPREPLY=($( compgen -W "$cmds" -- $cur ));
            return 0;
        else
            cmd=${COMP_WORDS[2]};
            case $cmd in 
                BATCH)
                    if [[ $COMP_CWORD -gt 3 ]] && [[ $lastToken != -* ]]; then
                        furtherOpts="";
                        fileNames=$( compgen -f -- "$cur" );
                        dirNames=$( compgen -d -- "$cur" );
                    else
                        furtherOpts="$versOpts $helpOpts $stdOpts $argOpts --no-timing";
                        fileNames=$( compgen -f -X '!*.@(R|r|S|s)' -- "$cur" );
                        dirNames=$( compgen -d -- "$cur" );
                    fi
                ;;
                COMPILE)
                    if [[ $COMP_CWORD -gt 3 ]] && [[ $lastToken != -* ]]; then
                        furtherOpts="";
                        fileNames=$( compgen -f -X '!*.@(c|cc|cpp|C|f)' -- "$cur" );
                        dirNames=$( compgen -d -- "$cur" );
                    else
                        furtherOpts="$versOpts $helpOpts -D";
                        fileNames=$( compgen -f -X '!*.@(c|cc|cpp|C|f)' -- "$cur" );
                        dirNames=$( compgen -d -- "$cur" );
                    fi
                ;;
                SHLIB)
                    if [[ $COMP_CWORD -gt 3 ]] && [[ $lastToken != -* ]]; then
                        furtherOpts="";
                        fileNames=$( compgen -f -X '!*.@(a|o)' -- "$cur" );
                        dirNames=$( compgen -d -- "$cur" );
                    else
                        furtherOpts="$versOpts $helpOpts -o --output -c --clean  --preclean -n --dry-run";
                        fileNames=$( compgen -f -X '!*.@(a|o)' -- "$cur" );
                        dirNames=$( compgen -d -- "$cur" );
                    fi
                ;;
                INSTALL)
                    if [[ $COMP_CWORD -gt 3 ]] && [[ $lastToken == @(-l|--library) ]]; then
                        furtherOpts="";
                        dirNames=$( compgen -d -- "$cur" );
                    else
                        furtherOpts="$versOpts $helpOpts                --configure-args --configure-vars -c --clean --preclean -d --debug -l  	--library --no-configure --no-docs --html --no-html --latex --example	--fake --no-lock --lock --pkglock --build --install-tests --no-R,	--no-libs --no-data --no-help --no-demo --no-exec --no-inst		--no-multiarch --libs-only --data-compress --resave-data		--compact-docs --with-keep.source --without-keep.source --byte-compile	--no-clean-on-error";
                        fileNames=$( compgen -f -X '!*.@(tar.gz|tgz)' -- "$cur" );
                        dirNames=$( compgen -d -- "$cur" );
                    fi
                ;;
                REMOVE)
                    furtherOpts="$versOpts $helpOpts -l --library";
                    if [[ $COMP_CWORD -gt 3 ]] && [[ $lastToken == @(-l|--library) ]]; then
                        dirNames=$( compgen -d -- "$cur" );
                    fi
                ;;
                build)
                    furtherOpts="$versOpts $helpOpts --force --keep-empty-dirs --no-vignettes --no-manual --resave-data --no-resave-data --compact-vignettes";
                    dirNames=$( compgen -d -- "$cur" )
                ;;
                check)
                    furtherOpts="$versOpts $helpOpts           -l --library -o --outdir				       --no-clean --no-codoc --no-examples --no-install --no-tests    --no-manual --no-vignettes --no-rebuild-vignettes --use-gct    --use-valgrind --timings --install-args --check-subdirs	       --extra-arch --multiarch --no-multiarch --force-multiarch";
                    fileNames=$( compgen -f -X '!*.@(tar.gz|tgz)' -- "$cur" );
                    dirNames=$( compgen -d -- "$cur" )
                ;;
                LINK)
                    furtherOpts="$versOpts $helpOpts"
                ;;
                Rprof)
                    furtherOpts="$versOpts $helpOpts --total --self --min%total --min%self";
                    fileNames=$( compgen -f -- "$cur" );
                    dirNames=$( compgen -d -- "$cur" )
                ;;
                Rdconv)
                    furtherOpts="$versOpts $helpOpts -t --type 		    --encoding --package -o --output --os --OS";
                    fileNames=$( compgen -f -X '!*.@(Rd)' -- "$cur" );
                    dirNames=$( compgen -d -- "$cur" )
                ;;
                Rd2pdf)
                    furtherOpts="$versOpts $helpOpts --batch            		    --no-clean --no-preview --encoding --outputEncoding                     --os --OS -o --output --force --title               		    --no-index --no-description --internals";
                    fileNames=$( compgen -f -X '!*.@(Rd)' -- "$cur" );
                    dirNames=$( compgen -d -- "$cur" )
                ;;
                Rd2txt)
                    furtherOpts="$versOpts $helpOpts -t --type --encoding --package -o --output --os --OS";
                    fileNames=$( compgen -f -X '!*.@(Rd)' -- "$cur" );
                    dirNames=$( compgen -d -- "$cur" )
                ;;
                Sweave)
                    if [[ $COMP_CWORD -gt 3 ]] && [[ $lastToken != -* ]]; then
                        return 0;
                    else
                        furtherOpts="$versOpts $helpOpts --driver --encoding --options --pdf";
                        fileNames=$( compgen -f -X '!*.@(Rnw|rnw|Snw|snw)' -- "$cur" );
                        dirNames=$( compgen -d -- "$cur" );
                    fi
                ;;
                Stangle)
                    if [[ $COMP_CWORD -gt 3 ]] && [[ $lastToken != -* ]]; then
                        return 0;
                    else
                        furtherOpts="$versOpts $helpOpts --encoding --options";
                        fileNames=$( compgen -f -X '!*.@(Rnw|rnw|Snw|snw)' -- "$cur" );
                        dirNames=$( compgen -d -- "$cur" );
                    fi
                ;;
                config)
                    if [[ $COMP_CWORD -gt 3 ]]; then
                        return 0;
                    else
                        furtherOpts="$versOpts $helpOpts --ldflags  --cppflags  BLAS_LIBS CC CFLAGS CPICFLAGS CPP CPPFLAGS CXX CXXCPP CXXFLAGS			CXXPICFLAGS DYLIB_EXT DYLIB_LD DYLIB_LDFLAGS F77 FFLAGS FLIBS			FPICFLAGS FC FCFLAGS FCPICFLAGS JAR JAVA JAVAC JAVAH JAVA_HOME			JAVA_LIBS JAVA_CPPFLAGS LAPACK_LIBS LIBnn LDFLAGS OBJC OBJCFLAGS MAKE		SAFE_FFLAGS SHLIB_CFLAGS SHLIB_CXXLD SHLIB_CXXLDFLAGS SHLIB_EXT			SHLIB_FFLAGS SHLIB_LD SHLIB_LDFLAGS SHLIB_FCLD, SHLIB_FCLDFLAGS			TCLTK_CPPFLAGS TCLTK_LIBS";
                    fi
                ;;
                javareconf)
                    furtherOpts="$versOpts $helpOpts -n --dry-run -e"
                ;;
                rtags)
                    furtherOpts="$versOpts $helpOpts -o --output --no-c --no-R                                 --no-Rd -a --append -V --verbose";
                    dirNames=$( compgen -d -- "$cur" )
                ;;
            esac;
        fi;
    else
        if [[ $lastToken == "<" ]]; then
            furtherOpts="";
            fileNames=$( compgen -f -X '!*.@(R|r|S|s)' -- "$cur" );
            dirNames=$( compgen -d -- "$cur" );
        else
            if [[ $lastToken == ">" ]]; then
                furtherOpts="";
                fileNames=$( compgen -f -- "$cur" );
                dirNames=$( compgen -d -- "$cur" );
            else
                case $lastToken in 
                    -g | --gui)
                        furtherOpts="X11 Tk"
                    ;;
                    -d | --debugger)
                        furtherOpts=$( compgen -c -- "$cur" )
                    ;;
                    *)
                        furtherOpts="$versOpts $helpOpts $stdOpts $argOpts"
                    ;;
                esac;
            fi;
        fi;
    fi;
    for ((i=1; i<=$COMP_CWORD-1; ++i ))
    do
        opt=${COMP_WORDS[$i]};
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        if [[ $opt == "<" ]]; then
            furtherOpts="";
        else
            if [[ $opt == ">" ]]; then
                furtherOpts="";
            fi;
        fi;
        allOpts=" $furtherOpts ";
        allOpts=${allOpts/ ${optBase} / };
        case $optBase in 
            -q | --quiet | --silent)
                allOpts=${allOpts/ -q / };
                allOpts=${allOpts/ --quiet / };
                allOpts=${allOpts/ --silent / }
            ;;
            --save | --no-save)
                allOpts=${allOpts/ --save / };
                allOpts=${allOpts/ --no-save / }
            ;;
            --vanilla)
                allOpts=${allOpts/ --no-save / };
                allOpts=${allOpts/ --no-restore / };
                allOpts=${allOpts/ --no-site-file / };
                allOpts=${allOpts/ --no-init-file / };
                allOpts=${allOpts/ --no-environ / }
            ;;
            -d)
                allOpts=${allOpts/ --debugger / }
            ;;
            --debugger)
                allOpts=${allOpts/ -d / }
            ;;
            --restore)
                allOpts=${allOpts/ --no-restore / }
            ;;
            --no-restore)
                allOpts=${allOpts/ --restore / }
            ;;
            -g | --gui)
                allOpts=${allOpts/ -g / };
                allOpts=${allOpts/ --gui / }
            ;;
            BATCH)
                allOpts=${allOpts/ --restore / };
                allOpts=${allOpts/ --save / };
                allOpts=${allOpts/ --no-readline / }
            ;;
        esac;
    done;
    COMPREPLY=($( compgen -W "$allOpts $fileNames $dirNames" -- $cur ));
    return 0
}
__all_modules () 
{ 
    while read name; do
        name=${name%% *};
        printf "%s\n" "$name";
    done < <(pulseaudio --dump-modules 2> /dev/null)
}
__cards () 
{ 
    while IFS='	' read idx name _; do
        printf "%s %s\n" "$idx" "$name";
    done < <(pactl list cards short 2> /dev/null)
}
__docker_complete_capabilities () 
{ 
    COMPREPLY=($( compgen -W "
		ALL
		AUDIT_CONTROL
		AUDIT_WRITE
		AUDIT_READ
		BLOCK_SUSPEND
		CHOWN
		DAC_OVERRIDE
		DAC_READ_SEARCH
		FOWNER
		FSETID
		IPC_LOCK
		IPC_OWNER
		KILL
		LEASE
		LINUX_IMMUTABLE
		MAC_ADMIN
		MAC_OVERRIDE
		MKNOD
		NET_ADMIN
		NET_BIND_SERVICE
		NET_BROADCAST
		NET_RAW
		SETFCAP
		SETGID
		SETPCAP
		SETUID
		SYS_ADMIN
		SYS_BOOT
		SYS_CHROOT
		SYSLOG
		SYS_MODULE
		SYS_NICE
		SYS_PACCT
		SYS_PTRACE
		SYS_RAWIO
		SYS_RESOURCE
		SYS_TIME
		SYS_TTY_CONFIG
		WAKE_ALARM
	" -- "$cur" ))
}
__docker_complete_container_ids () 
{ 
    local containers=($(__docker_q ps -aq));
    COMPREPLY=($(compgen -W "${containers[*]}" -- "$cur"))
}
__docker_complete_container_names () 
{ 
    local containers=($(__docker_q ps -aq --no-trunc));
    local names=($(__docker_q inspect --format '{{.Name}}' "${containers[@]}"));
    names=("${names[@]#/}");
    COMPREPLY=($(compgen -W "${names[*]}" -- "$cur"))
}
__docker_complete_containers_all () 
{ 
    local IFS='
';
    local containers=($(__docker_q ps -aq --no-trunc));
    if [ "$1" ]; then
        containers=($(__docker_q inspect --format "{{if $1}}{{.Id}}{{end}}" "${containers[@]}"));
    fi;
    local names=($(__docker_q inspect --format '{{.Name}}' "${containers[@]}"));
    names=("${names[@]#/}");
    unset IFS;
    COMPREPLY=($(compgen -W "${names[*]} ${containers[*]}" -- "$cur"))
}
__docker_complete_containers_and_images () 
{ 
    __docker_complete_containers_all;
    local containers=("${COMPREPLY[@]}");
    __docker_complete_images;
    COMPREPLY+=("${containers[@]}")
}
__docker_complete_containers_in_network () 
{ 
    local containers=$(__docker_q network inspect -f '{{range $i, $c := .Containers}}{{$i}} {{$c.Name}} {{end}}' "$1");
    COMPREPLY=($(compgen -W "$containers" -- "$cur"))
}
__docker_complete_containers_pauseable () 
{ 
    __docker_complete_containers_all 'and .State.Running (not .State.Paused)'
}
__docker_complete_containers_running () 
{ 
    __docker_complete_containers_all '.State.Running'
}
__docker_complete_containers_stopped () 
{ 
    __docker_complete_containers_all 'not .State.Running'
}
__docker_complete_containers_unpauseable () 
{ 
    __docker_complete_containers_all '.State.Paused'
}
__docker_complete_detach-keys () 
{ 
    case "$prev" in 
        --detach-keys)
            case "$cur" in 
                *,)
                    COMPREPLY=($( compgen -W "${cur}ctrl-" -- "$cur" ))
                ;;
                *)
                    COMPREPLY=($( compgen -W "ctrl-" -- "$cur" ))
                ;;
            esac;
            __docker_nospace;
            return
        ;;
    esac;
    return 1
}
__docker_complete_image_repos () 
{ 
    local repos="$(__docker_q images | awk 'NR>1 && $1 != "<none>" { print $1 }')";
    COMPREPLY=($(compgen -W "$repos" -- "$cur"))
}
__docker_complete_image_repos_and_tags () 
{ 
    local reposAndTags="$(__docker_q images | awk 'NR>1 && $1 != "<none>" { print $1; print $1":"$2 }')";
    COMPREPLY=($(compgen -W "$reposAndTags" -- "$cur"));
    __ltrim_colon_completions "$cur"
}
__docker_complete_images () 
{ 
    local images_args="";
    case "$DOCKER_COMPLETION_SHOW_IMAGE_IDS" in 
        all)
            images_args="--no-trunc -a"
        ;;
        non-intermediate)
            images_args="--no-trunc"
        ;;
    esac;
    local repo_print_command;
    if [ "${DOCKER_COMPLETION_SHOW_TAGS:-yes}" = "yes" ]; then
        repo_print_command='print $1; print $1":"$2';
    else
        repo_print_command='print $1';
    fi;
    local awk_script;
    case "$DOCKER_COMPLETION_SHOW_IMAGE_IDS" in 
        all | non-intermediate)
            awk_script='NR>1 { print $3; if ($1 != "<none>") { '"$repo_print_command"' } }'
        ;;
        none | *)
            awk_script='NR>1 && $1 != "<none>" { '"$repo_print_command"' }'
        ;;
    esac;
    local images=$(__docker_q images $images_args | awk "$awk_script");
    COMPREPLY=($(compgen -W "$images" -- "$cur"));
    __ltrim_colon_completions "$cur"
}
__docker_complete_isolation () 
{ 
    COMPREPLY=($( compgen -W "default hyperv process" -- "$cur" ))
}
__docker_complete_log_driver_options () 
{ 
    case "${words[$cword-2]}$prev=" in 
        *gelf-address=*)
            COMPREPLY=($( compgen -W "udp" -S "://" -- "${cur#=}" ));
            __docker_nospace;
            return
        ;;
        *syslog-address=*)
            COMPREPLY=($( compgen -W "tcp:// tcp+tls:// udp:// unix://" -- "${cur#=}" ));
            __docker_nospace;
            __ltrim_colon_completions "${cur}";
            return
        ;;
        *syslog-facility=*)
            COMPREPLY=($( compgen -W "
				auth
				authpriv
				cron
				daemon
				ftp
				kern
				local0
				local1
				local2
				local3
				local4
				local5
				local6
				local7
				lpr
				mail
				news
				syslog
				user
				uucp
			" -- "${cur#=}" ));
            return
        ;;
        *syslog-tls-@(ca-cert|cert|key)=*)
            _filedir;
            return
        ;;
        *syslog-tls-skip-verify=*)
            COMPREPLY=($( compgen -W "true" -- "${cur#=}" ));
            return
        ;;
        *splunk-url=*)
            COMPREPLY=($( compgen -W "http:// https://" -- "${cur#=}" ));
            __docker_nospace;
            __ltrim_colon_completions "${cur}";
            return
        ;;
        *splunk-insecureskipverify=*)
            COMPREPLY=($( compgen -W "true false" -- "${cur#=}" ));
            __docker_nospace;
            return
        ;;
    esac;
    return 1
}
__docker_complete_log_drivers () 
{ 
    COMPREPLY=($( compgen -W "
		awslogs
		fluentd
		gelf
		journald
		json-file
		none
		splunk
		syslog
	" -- "$cur" ))
}
__docker_complete_log_levels () 
{ 
    COMPREPLY=($( compgen -W "debug info warn error fatal" -- "$cur" ))
}
__docker_complete_log_options () 
{ 
    local awslogs_options="awslogs-region awslogs-group awslogs-stream";
    local fluentd_options="env fluentd-address labels tag";
    local gelf_options="env gelf-address labels tag";
    local journald_options="env labels";
    local json_file_options="env labels max-file max-size";
    local syslog_options="syslog-address syslog-tls-ca-cert syslog-tls-cert syslog-tls-key syslog-tls-skip-verify syslog-facility tag";
    local splunk_options="env labels splunk-caname splunk-capath splunk-index splunk-insecureskipverify splunk-source splunk-sourcetype splunk-token splunk-url tag";
    local all_options="$fluentd_options $gelf_options $journald_options $json_file_options $syslog_options $splunk_options";
    case $(__docker_value_of_option --log-driver) in 
        '')
            COMPREPLY=($( compgen -W "$all_options" -S = -- "$cur" ))
        ;;
        awslogs)
            COMPREPLY=($( compgen -W "$awslogs_options" -S = -- "$cur" ))
        ;;
        fluentd)
            COMPREPLY=($( compgen -W "$fluentd_options" -S = -- "$cur" ))
        ;;
        gelf)
            COMPREPLY=($( compgen -W "$gelf_options" -S = -- "$cur" ))
        ;;
        journald)
            COMPREPLY=($( compgen -W "$journald_options" -S = -- "$cur" ))
        ;;
        json-file)
            COMPREPLY=($( compgen -W "$json_file_options" -S = -- "$cur" ))
        ;;
        syslog)
            COMPREPLY=($( compgen -W "$syslog_options" -S = -- "$cur" ))
        ;;
        splunk)
            COMPREPLY=($( compgen -W "$splunk_options" -S = -- "$cur" ))
        ;;
        *)
            return
        ;;
    esac;
    __docker_nospace
}
__docker_complete_network_ids () 
{ 
    COMPREPLY=($(compgen -W "$(__docker_q network ls -q --no-trunc)" -- "$cur"))
}
__docker_complete_network_names () 
{ 
    COMPREPLY=($(compgen -W "$(__docker_q network ls | awk 'NR>1 {print $2}')" -- "$cur"))
}
__docker_complete_networks () 
{ 
    COMPREPLY=($(compgen -W "$(__docker_networks)" -- "$cur"))
}
__docker_complete_plugins () 
{ 
    COMPREPLY=($(compgen -W "$(__docker_plugins $1)" -- "$cur"))
}
__docker_complete_resolved_hostname () 
{ 
    command -v host > /dev/null 2>&1 || return;
    COMPREPLY=($(host 2>/dev/null "${cur%:}" | awk '/has address/ {print $4}'))
}
__docker_complete_signals () 
{ 
    local signals=(SIGCONT SIGHUP SIGINT SIGKILL SIGQUIT SIGSTOP SIGTERM SIGUSR1 SIGUSR2);
    COMPREPLY=($( compgen -W "${signals[*]} ${signals[*]#SIG}" -- "$( echo $cur | tr '[:lower:]' '[:upper:]')" ))
}
__docker_complete_volumes () 
{ 
    COMPREPLY=($(compgen -W "$(__docker_q volume ls -q)" -- "$cur"))
}
__docker_map_key_of_current_option () 
{ 
    local glob="$1";
    local key glob_pos;
    if [ "$cur" = "=" ]; then
        key="$prev";
        glob_pos=$((cword - 2));
    else
        if [[ $cur == *=* ]]; then
            key=${cur%=*};
            glob_pos=$((cword - 1));
        else
            if [ "$prev" = "=" ]; then
                key=${words[$cword - 2]};
                glob_pos=$((cword - 3));
            else
                return;
            fi;
        fi;
    fi;
    [ "${words[$glob_pos]}" = "=" ] && ((glob_pos--));
    [[ ${words[$glob_pos]} == @($glob) ]] && echo "$key"
}
__docker_networks () 
{ 
    local fields='$2';
    [ "${DOCKER_COMPLETION_SHOW_NETWORK_IDS}" = yes ] && fields='$1,$2';
    __docker_q network ls --no-trunc | awk "NR>1 {print $fields}"
}
__docker_nospace () 
{ 
    type compopt &> /dev/null && compopt -o nospace
}
__docker_plugins () 
{ 
    __docker_q info | sed -n "/^Plugins/,/^[^ ]/s/ $1: //p"
}
__docker_pos_first_nonflag () 
{ 
    local argument_flags=$1;
    local counter=$((${subcommand_pos:-${command_pos}} + 1));
    while [ $counter -le $cword ]; do
        if [ -n "$argument_flags" ] && eval "case '${words[$counter]}' in $argument_flags) true ;; *) false ;; esac"; then
            (( counter++ ));
            [ "${words[$counter]}" = "=" ] && (( counter++ ));
        else
            case "${words[$counter]}" in 
                -*)

                ;;
                *)
                    break
                ;;
            esac;
        fi;
        while [ "${words[$counter + 1]}" = "=" ]; do
            counter=$(( counter + 2));
        done;
        (( counter++ ));
    done;
    echo $counter
}
__docker_q () 
{ 
    docker ${host:+-H "$host"} ${config:+--config "$config"} "$@" 2> /dev/null
}
__docker_subcommands () 
{ 
    local subcommands="$1";
    local counter=$(($command_pos + 1));
    while [ $counter -lt $cword ]; do
        case "${words[$counter]}" in 
            $(__docker_to_extglob "$subcommands"))
                subcommand_pos=$counter;
                local subcommand=${words[$counter]};
                local completions_func=_docker_${command}_${subcommand};
                declare -F $completions_func > /dev/null && $completions_func;
                return 0
            ;;
        esac;
        (( counter++ ));
    done;
    return 1
}
__docker_to_alternatives () 
{ 
    local parts=($1);
    local IFS='|';
    echo "${parts[*]}"
}
__docker_to_extglob () 
{ 
    local extglob=$( __docker_to_alternatives "$1" );
    echo "@($extglob)"
}
__docker_value_of_option () 
{ 
    local option_extglob=$(__docker_to_extglob "$1");
    local counter=$((command_pos + 1));
    while [ $counter -lt $cword ]; do
        case ${words[$counter]} in 
            $option_extglob)
                echo ${words[$counter + 1]};
                break
            ;;
        esac;
        (( counter++ ));
    done
}
__expand_tilde_by_ref () 
{ 
    if [[ ${!1} == \~* ]]; then
        if [[ ${!1} == */* ]]; then
            eval $1="${!1/%\/*}"/'${!1#*/}';
        else
            eval $1="${!1}";
        fi;
    fi
}
__gdbus () 
{ 
    local IFS='
';
    local cur=`_get_cword :`;
    local suggestions=$(gdbus complete "${COMP_LINE}" ${COMP_POINT});
    COMPREPLY=($(compgen -W "$suggestions" -- "$cur"));
    case "$cur" in 
        *:*)
            case "$COMP_WORDBREAKS" in 
                *:*)
                    local colon_word=${cur%${cur##*:}};
                    local i=${#COMPREPLY[*]};
                    while [ $((--i)) -ge 0 ]; do
                        COMPREPLY[$i]=${COMPREPLY[$i]#"$colon_word"};
                    done
                ;;
            esac
        ;;
    esac
}
__get_cword_at_cursor_by_ref () 
{ 
    local cword words=();
    __reassemble_comp_words_by_ref "$1" words cword;
    local i cur index=$COMP_POINT lead=${COMP_LINE:0:$COMP_POINT};
    if [[ $index -gt 0 && ( -n $lead && -n ${lead//[[:space:]]} ) ]]; then
        cur=$COMP_LINE;
        for ((i = 0; i <= cword; ++i ))
        do
            while [[ ${#cur} -ge ${#words[i]} && "${cur:0:${#words[i]}}" != "${words[i]}" ]]; do
                cur="${cur:1}";
                ((index--));
            done;
            if [[ $i -lt $cword ]]; then
                local old_size=${#cur};
                cur="${cur#"${words[i]}"}";
                local new_size=${#cur};
                index=$(( index - old_size + new_size ));
            fi;
        done;
        [[ -n $cur && ! -n ${cur//[[:space:]]} ]] && cur=;
        [[ $index -lt 0 ]] && index=0;
    fi;
    local "$2" "$3" "$4" && _upvars -a${#words[@]} $2 "${words[@]}" -v $3 "$cword" -v $4 "${cur:0:$index}"
}
__git_ps1 () 
{ 
    local pcmode=no;
    local detached=no;
    local ps1pc_start='\u@\h:\w ';
    local ps1pc_end='\$ ';
    local printf_format=' (%s)';
    case "$#" in 
        2 | 3)
            pcmode=yes;
            ps1pc_start="$1";
            ps1pc_end="$2";
            printf_format="${3:-$printf_format}"
        ;;
        0 | 1)
            printf_format="${1:-$printf_format}"
        ;;
        *)
            return
        ;;
    esac;
    local repo_info rev_parse_exit_code;
    repo_info="$(git rev-parse --git-dir --is-inside-git-dir 		--is-bare-repository --is-inside-work-tree 		--short HEAD 2>/dev/null)";
    rev_parse_exit_code="$?";
    if [ -z "$repo_info" ]; then
        if [ $pcmode = yes ]; then
            PS1="$ps1pc_start$ps1pc_end";
        fi;
        return;
    fi;
    local short_sha;
    if [ "$rev_parse_exit_code" = "0" ]; then
        short_sha="${repo_info##*
}";
        repo_info="${repo_info%
*}";
    fi;
    local inside_worktree="${repo_info##*
}";
    repo_info="${repo_info%
*}";
    local bare_repo="${repo_info##*
}";
    repo_info="${repo_info%
*}";
    local inside_gitdir="${repo_info##*
}";
    local g="${repo_info%
*}";
    local r="";
    local b="";
    local step="";
    local total="";
    if [ -d "$g/rebase-merge" ]; then
        read b 2> /dev/null < "$g/rebase-merge/head-name";
        read step 2> /dev/null < "$g/rebase-merge/msgnum";
        read total 2> /dev/null < "$g/rebase-merge/end";
        if [ -f "$g/rebase-merge/interactive" ]; then
            r="|REBASE-i";
        else
            r="|REBASE-m";
        fi;
    else
        if [ -d "$g/rebase-apply" ]; then
            read step 2> /dev/null < "$g/rebase-apply/next";
            read total 2> /dev/null < "$g/rebase-apply/last";
            if [ -f "$g/rebase-apply/rebasing" ]; then
                read b 2> /dev/null < "$g/rebase-apply/head-name";
                r="|REBASE";
            else
                if [ -f "$g/rebase-apply/applying" ]; then
                    r="|AM";
                else
                    r="|AM/REBASE";
                fi;
            fi;
        else
            if [ -f "$g/MERGE_HEAD" ]; then
                r="|MERGING";
            else
                if [ -f "$g/CHERRY_PICK_HEAD" ]; then
                    r="|CHERRY-PICKING";
                else
                    if [ -f "$g/REVERT_HEAD" ]; then
                        r="|REVERTING";
                    else
                        if [ -f "$g/BISECT_LOG" ]; then
                            r="|BISECTING";
                        fi;
                    fi;
                fi;
            fi;
        fi;
        if [ -n "$b" ]; then
            :;
        else
            if [ -h "$g/HEAD" ]; then
                b="$(git symbolic-ref HEAD 2>/dev/null)";
            else
                local head="";
                if ! read head 2> /dev/null < "$g/HEAD"; then
                    if [ $pcmode = yes ]; then
                        PS1="$ps1pc_start$ps1pc_end";
                    fi;
                    return;
                fi;
                b="${head#ref: }";
                if [ "$head" = "$b" ]; then
                    detached=yes;
                    b="$(
				case "${GIT_PS1_DESCRIBE_STYLE-}" in
				(contains)
					git describe --contains HEAD ;;
				(branch)
					git describe --contains --all HEAD ;;
				(describe)
					git describe HEAD ;;
				(* | default)
					git describe --tags --exact-match HEAD ;;
				esac 2>/dev/null)" || b="$short_sha...";
                    b="($b)";
                fi;
            fi;
        fi;
    fi;
    if [ -n "$step" ] && [ -n "$total" ]; then
        r="$r $step/$total";
    fi;
    local w="";
    local i="";
    local s="";
    local u="";
    local c="";
    local p="";
    if [ "true" = "$inside_gitdir" ]; then
        if [ "true" = "$bare_repo" ]; then
            c="BARE:";
        else
            b="GIT_DIR!";
        fi;
    else
        if [ "true" = "$inside_worktree" ]; then
            if [ -n "${GIT_PS1_SHOWDIRTYSTATE-}" ] && [ "$(git config --bool bash.showDirtyState)" != "false" ]; then
                git diff --no-ext-diff --quiet --exit-code || w="*";
                if [ -n "$short_sha" ]; then
                    git diff-index --cached --quiet HEAD -- || i="+";
                else
                    i="#";
                fi;
            fi;
            if [ -n "${GIT_PS1_SHOWSTASHSTATE-}" ] && [ -r "$g/refs/stash" ]; then
                s="$";
            fi;
            if [ -n "${GIT_PS1_SHOWUNTRACKEDFILES-}" ] && [ "$(git config --bool bash.showUntrackedFiles)" != "false" ] && git ls-files --others --exclude-standard --error-unmatch -- '*' > /dev/null 2> /dev/null; then
                u="%${ZSH_VERSION+%}";
            fi;
            if [ -n "${GIT_PS1_SHOWUPSTREAM-}" ]; then
                __git_ps1_show_upstream;
            fi;
        fi;
    fi;
    local z="${GIT_PS1_STATESEPARATOR-" "}";
    if [ $pcmode = yes ] && [ -n "${GIT_PS1_SHOWCOLORHINTS-}" ]; then
        __git_ps1_colorize_gitstring;
    fi;
    local f="$w$i$s$u";
    local gitstring="$c${b##refs/heads/}${f:+$z$f}$r$p";
    if [ $pcmode = yes ]; then
        if [ "${__git_printf_supports_v-}" != yes ]; then
            gitstring=$(printf -- "$printf_format" "$gitstring");
        else
            printf -v gitstring -- "$printf_format" "$gitstring";
        fi;
        PS1="$ps1pc_start$gitstring$ps1pc_end";
    else
        printf -- "$printf_format" "$gitstring";
    fi
}
__git_ps1_colorize_gitstring () 
{ 
    if [[ -n ${ZSH_VERSION-} ]]; then
        local c_red='%F{red}';
        local c_green='%F{green}';
        local c_lblue='%F{blue}';
        local c_clear='%f';
    else
        local c_red='\[\e[31m\]';
        local c_green='\[\e[32m\]';
        local c_lblue='\[\e[1;34m\]';
        local c_clear='\[\e[0m\]';
    fi;
    local bad_color=$c_red;
    local ok_color=$c_green;
    local flags_color="$c_lblue";
    local branch_color="";
    if [ $detached = no ]; then
        branch_color="$ok_color";
    else
        branch_color="$bad_color";
    fi;
    c="$branch_color$c";
    z="$c_clear$z";
    if [ "$w" = "*" ]; then
        w="$bad_color$w";
    fi;
    if [ -n "$i" ]; then
        i="$ok_color$i";
    fi;
    if [ -n "$s" ]; then
        s="$flags_color$s";
    fi;
    if [ -n "$u" ]; then
        u="$bad_color$u";
    fi;
    r="$c_clear$r"
}
__git_ps1_show_upstream () 
{ 
    local key value;
    local svn_remote svn_url_pattern count n;
    local upstream=git legacy="" verbose="" name="";
    svn_remote=();
    local output="$(git config -z --get-regexp '^(svn-remote\..*\.url|bash\.showupstream)$' 2>/dev/null | tr '\0\n' '\n ')";
    while read -r key value; do
        case "$key" in 
            bash.showupstream)
                GIT_PS1_SHOWUPSTREAM="$value";
                if [[ -z "${GIT_PS1_SHOWUPSTREAM}" ]]; then
                    p="";
                    return;
                fi
            ;;
            svn-remote.*.url)
                svn_remote[$((${#svn_remote[@]} + 1))]="$value";
                svn_url_pattern="$svn_url_pattern\\|$value";
                upstream=svn+git
            ;;
        esac;
    done <<< "$output";
    for option in ${GIT_PS1_SHOWUPSTREAM};
    do
        case "$option" in 
            git | svn)
                upstream="$option"
            ;;
            verbose)
                verbose=1
            ;;
            legacy)
                legacy=1
            ;;
            name)
                name=1
            ;;
        esac;
    done;
    case "$upstream" in 
        git)
            upstream="@{upstream}"
        ;;
        svn*)
            local -a svn_upstream;
            svn_upstream=($(git log --first-parent -1 					--grep="^git-svn-id: \(${svn_url_pattern#??}\)" 2>/dev/null));
            if [[ 0 -ne ${#svn_upstream[@]} ]]; then
                svn_upstream=${svn_upstream[${#svn_upstream[@]} - 2]};
                svn_upstream=${svn_upstream%@*};
                local n_stop="${#svn_remote[@]}";
                for ((n=1; n <= n_stop; n++))
                do
                    svn_upstream=${svn_upstream#${svn_remote[$n]}};
                done;
                if [[ -z "$svn_upstream" ]]; then
                    upstream=${GIT_SVN_ID:-git-svn};
                else
                    upstream=${svn_upstream#/};
                fi;
            else
                if [[ "svn+git" = "$upstream" ]]; then
                    upstream="@{upstream}";
                fi;
            fi
        ;;
    esac;
    if [[ -z "$legacy" ]]; then
        count="$(git rev-list --count --left-right 				"$upstream"...HEAD 2>/dev/null)";
    else
        local commits;
        if commits="$(git rev-list --left-right "$upstream"...HEAD 2>/dev/null)"; then
            local commit behind=0 ahead=0;
            for commit in $commits;
            do
                case "$commit" in 
                    "<"*)
                        ((behind++))
                    ;;
                    *)
                        ((ahead++))
                    ;;
                esac;
            done;
            count="$behind	$ahead";
        else
            count="";
        fi;
    fi;
    if [[ -z "$verbose" ]]; then
        case "$count" in 
            "")
                p=""
            ;;
            "0	0")
                p="="
            ;;
            "0	"*)
                p=">"
            ;;
            *"	0")
                p="<"
            ;;
            *)
                p="<>"
            ;;
        esac;
    else
        case "$count" in 
            "")
                p=""
            ;;
            "0	0")
                p=" u="
            ;;
            "0	"*)
                p=" u+${count#0	}"
            ;;
            *"	0")
                p=" u-${count%	0}"
            ;;
            *)
                p=" u+${count#*	}-${count%	*}"
            ;;
        esac;
        if [[ -n "$count" && -n "$name" ]]; then
            p="$p $(git rev-parse --abbrev-ref "$upstream" 2>/dev/null)";
        fi;
    fi
}
__gresource () 
{ 
    local choices coffset section;
    if [ ${COMP_CWORD} -gt 2 ]; then
        if [ ${COMP_WORDS[1]} = --section ]; then
            section=${COMP_WORDS[2]};
            coffset=2;
        else
            coffset=0;
        fi;
    else
        coffset=0;
    fi;
    case "$((${COMP_CWORD}-$coffset))" in 
        1)
            choices='--section 
help 
sections 
list 
details 
extract '
        ;;
        2)
            case "${COMP_WORDS[$(($coffset+1))]}" in 
                --section)
                    return 0
                ;;
                help)
                    choices='sections
list
details
extract'
                ;;
                sections | list | details | extract)
                    COMPREPLY=($(compgen -f -- ${COMP_WORDS[${COMP_CWORD}]}));
                    return 0
                ;;
            esac
        ;;
        3)
            case "${COMP_WORDS[$(($coffset+1))]}" in 
                list | details | extract)
                    choices="$(gresource list ${COMP_WORDS[$(($coffset+2))]} 2> /dev/null | sed -e 's.$. .')"
                ;;
            esac
        ;;
    esac;
    local IFS='
';
    COMPREPLY=($(compgen -W "${choices}" -- "${COMP_WORDS[${COMP_CWORD}]}"))
}
__grub_dir () 
{ 
    local i c=1 boot_dir;
    for ((c=1; c <= ${#COMP_WORDS[@]}; c++ ))
    do
        i="${COMP_WORDS[c]}";
        case "$i" in 
            --boot-directory)
                c=$((++c));
                i="${COMP_WORDS[c]}";
                boot_dir="${i##*=}";
                break
            ;;
        esac;
    done;
    boot_dir=${boot_dir-/boot};
    echo "${boot_dir%/}/grub"
}
__grub_get_last_option () 
{ 
    local i;
    for ((i=$COMP_CWORD-1; i > 0; i-- ))
    do
        if [[ "${COMP_WORDS[i]}" == -* ]]; then
            echo "${COMP_WORDS[i]}";
            break;
        fi;
    done
}
__grub_get_options_from_help () 
{ 
    local prog;
    if [ $# -ge 1 ]; then
        prog="$1";
    else
        prog="${COMP_WORDS[0]}";
    fi;
    local i IFS=" "'	''
';
    for i in $(LC_ALL=C $prog --help);
    do
        case $i in 
            --*)
                echo "${i%=*}"
            ;;
        esac;
    done
}
__grub_get_options_from_usage () 
{ 
    local prog;
    if [ $# -ge 1 ]; then
        prog="$1";
    else
        prog="${COMP_WORDS[0]}";
    fi;
    local i IFS=" "'	''
';
    for i in $(LC_ALL=C $prog --usage);
    do
        case $i in 
            \[--*\])
                i=${i#[};
                echo ${i%%?(=*)]}
            ;;
        esac;
    done
}
__grub_list_menuentries () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    local config_file=$(__grub_dir)/grub.cfg;
    if [ -f "$config_file" ]; then
        local IFS='
';
        COMPREPLY=($(compgen             -W "$( awk -F "[\"']" '/menuentry/ { print $2 }' $config_file )"             -- "$cur" ));
    fi
}
__grub_list_modules () 
{ 
    local grub_dir=$(__grub_dir);
    local IFS='
';
    COMPREPLY=($( compgen -f -X '!*/*.mod' -- "${grub_dir}/$cur" | {
         while read -r tmp; do
             [ -n $tmp ] && {
                 tmp=${tmp##*/}
                 printf '%s\n' ${tmp%.mod}
             }
         done
         }
        ))
}
__grubcomp () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    if [ $# -gt 2 ]; then
        cur="$3";
    fi;
    case "$cur" in 
        --*=)
            COMPREPLY=()
        ;;
        *)
            local IFS=' ''	''
';
            COMPREPLY=($(compgen -P "${2-}" -W "${1-}" -S "${4-}" -- "$cur"))
        ;;
    esac
}
__gsettings () 
{ 
    local choices coffset schemadir;
    if [ ${COMP_CWORD} -gt 2 ]; then
        if [ ${COMP_WORDS[1]} = --schemadir ]; then
            schemadir=$(eval "echo --schemadir ${COMP_WORDS[2]}");
            coffset=2;
        else
            coffset=0;
        fi;
    else
        coffset=0;
    fi;
    case "$((${COMP_CWORD}-$coffset))" in 
        1)
            choices='--schemadir
help 
list-schemas
list-relocatable-schemas
list-keys 
list-children 
list-recursively 
get 
range 
set 
reset 
reset-recursively 
writable 
monitor'
        ;;
        2)
            case "${COMP_WORDS[$(($coffset+1))]}" in 
                --schemadir)
                    COMPREPLY=($(compgen -o dirnames -- ${COMP_WORDS[${COMP_CWORD}]}));
                    return 0
                ;;
                help)
                    choices='list-schemas
list-relocatable-schemas
list-keys
list-children
list-recursively
get
range
set
reset
reset-recursively
writable
monitor'
                ;;
                list-keys | list-children | list-recursively | reset-recursively)
                    choices="$(gsettings $schemadir list-schemas)"'
'"$(gsettings $schemadir list-relocatable-schemas | sed -e 's.$.:/.')"
                ;;
                get | range | set | reset | writable | monitor)
                    choices="$(gsettings $schemadir list-schemas | sed -e 's.$. .')"'
'"$(gsettings $schemadir list-relocatable-schemas | sed -e 's.$.:/.')"
                ;;
            esac
        ;;
        3)
            case "${COMP_WORDS[$(($coffset+1))]}" in 
                set)
                    choices="$(gsettings $schemadir list-keys ${COMP_WORDS[$(($coffset+2))]} 2> /dev/null | sed -e 's.$. .')"
                ;;
                get | range | reset | writable | monitor)
                    choices="$(gsettings $schemadir list-keys ${COMP_WORDS[$(($coffset+2))]} 2> /dev/null)"
                ;;
            esac
        ;;
        4)
            case "${COMP_WORDS[$(($coffset+2))]}" in 
                set)
                    range=($(gsettings $schemadir range ${COMP_WORDS[$(($coffset+2))]} ${COMP_WORDS[$(($coffset+3))]} 2> /dev/null));
                    case "${range[0]}" in 
                        enum)
                            unset range[0]
                        ;;
                        *)
                            unset range
                        ;;
                    esac;
                    local IFS='
';
                    choices="${range[*]}"
                ;;
            esac
        ;;
    esac;
    local IFS='
';
    COMPREPLY=($(compgen -W "${choices}" -- "${COMP_WORDS[${COMP_CWORD}]}"))
}
__loaded_modules () 
{ 
    while IFS='	' read idx name _; do
        printf "%s %s\n" "$idx" "$name";
    done < <(pactl list modules short 2> /dev/null)
}
__ltrim_colon_completions () 
{ 
    if [[ "$1" == *:* && "$COMP_WORDBREAKS" == *:* ]]; then
        local colon_word=${1%"${1##*:}"};
        local i=${#COMPREPLY[*]};
        while [[ $((--i)) -ge 0 ]]; do
            COMPREPLY[$i]=${COMPREPLY[$i]#"$colon_word"};
        done;
    fi
}
__mvnarchetype_generate () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    __mvncomp "archetypeArtifactId= archetypeCatalog= archetypeGroupId= archetypeRepository= archetypeVersion= basedir= goals= interactiveMode=" "-D" "${cur}"
}
__mvncomp () 
{ 
    local genOpt=;
    if [ "$1" == "-nospace" ]; then
        genOpt="true";
        shift;
    fi;
    local cur="${COMP_WORDS[COMP_CWORD]}";
    if [ $# -gt 2 ]; then
        cur="$3";
    fi;
    case "$cur" in 
        -*=)
            COMPREPLY=()
        ;;
        *)
            local IFS='
';
            COMPREPLY=($(compgen -P "$2" 			-W "$(__mvncomp_1 "$1" "$4")" 			-- "$cur"))
        ;;
    esac
}
__mvncomp_1 () 
{ 
    local c IFS=' ''	''
';
    for c in $1;
    do
        case "$c$2" in 
            --*=*)
                printf %s'
' "$c$2"
            ;;
            *.)
                printf %s'
' "$c$2"
            ;;
            *)
                printf %s'
' "$c$2 "
            ;;
        esac;
    done
}
__mvndependency_analyze () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    __mvncomp "ignoreNonCompile=true outputXML=true scriptableFlag= scriptableOutput=true verbose=true" "-D" "${cur}"
}
__mvndependency_analyze_dep_mgt () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    __mvncomp "ignoreDirect=false" "-D" "${cur}"
}
__mvndependency_purge_local_repository () 
{ 
    local fuzziness="file version artifactId groupId";
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    case "${cur}" in 
        resolutionFuzziness=*)
            __mvncomp "${fuzziness}" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        *)
            __mvncomp "actTransitively=false exclude= reResolve=false verbose=true
			$(__mvnlist_prefix 'resolutionFuzziness=' ${fuzziness})";
            "-D" "${cur}"
        ;;
    esac
}
__mvndependency_resolve () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    case "${cur}" in 
        classifier=*)
            __mvncomp "${__mvnclassifiers}" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        *)
            __mvncomp "$(__mvnlist_prefix 'classifier=' ${__mvnclassifiers}) excludeArtifactIds= excludeClassifiers= excludeGroupIds=
			excludeScope= excludeTransitive=true excludeTypes= includeArtifactIds= includeClassifiers= includeGroupIds= includeScope= 
			includeTypes= markersDirectory= outputAbsoluteArtifactFilename= outputFile= outputScope=false overWriteIfNewer=false
			overWriteReleases=true overWriteSnapshots=true silent=true type=";
            "-D" "${cur}"
        ;;
    esac
}
__mvndependency_tree () 
{ 
    local tokens="whitespace standard extended";
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    case "${cur}" in 
        tokens=*)
            __mvncomp "${tokens}" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        *)
            __mvncomp "excludes= includes= outputFile= scope= verbose=true
			$(__mvnlist_prefix 'tokens=' ${tokens})";
            "-D" "${cur}"
        ;;
    esac
}
__mvndependency_x_dependencies () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    case "${cur}" in 
        classifier=*)
            __mvncomp "${__mvnclassifiers}" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        *)
            __mvncomp "$(__mvnlist_prefix 'classifier=' ${__mvnclassifiers})" "-D" "${cur}"
        ;;
    esac
}
__mvndeploy_deploy () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    __mvncomp "altDeploymentRepository= skip=true updateReleaseInfo=true" "-D" "${cur}"
}
__mvndeploy_deploy_file () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    case "${cur}" in 
        file=*)
            COMPREPLY=($( compgen -f -P "$(__mvnprefix_equals $cur)" -- "${cur#*=}" ))
        ;;
        pomFile=*)
            __mvncomp "$(__mvnlist_poms)" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        packaging=*)
            __mvncomp "${__mvnpackaging}" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        *)
            local options="artifactId= classifier= description= file=press file=tab generatePom=true groupId= pomFile=press pomFile=tab repositoryId= 
		  repositoryLayout=legacy uniqueVersion=false url= version=";
            options="$options $(__mvnlist_prefix 'packaging=' ${__mvnpackaging} )";
            __mvncomp "$options" "-D" "${cur}"
        ;;
    esac
}
__mvnhelp_describe () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    case "${cur}" in 
        cmd=*:*)
            local plugin="${cur#*=}";
            plugin="${plugin%%:*}:";
            __mvncomp "$(__mvnlist_goals $plugin)" "$(__mvnprefix_colon $cur)" "${cur#*:}"
        ;;
        cmd=*)
            __mvncomp "${__mvnphases} ${__mvnall_plugin_and_goals}" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        plugin=*)
            __mvncomp "org.apache.maven.plugins:maven-" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        groupId=*)
            __mvncomp "org.apache.maven.plugins" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        artifactId=*)
            __mvncomp "" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        *)
            __mvncomp "detail cmd=press cmd=tab plugin= groupId= artifactId=" "-D" "${cur}"
        ;;
    esac
}
__mvninstall_install_file () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    case "${cur}" in 
        file=*)
            COMPREPLY=($( compgen -f -P "$(__mvnprefix_equals $cur)" -- "${cur#*=}" ))
        ;;
        pomFile=*)
            __mvncomp "$(__mvnlist_poms)" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        sources=*)
            __mvncomp "$(__mvnlist_jars)" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        javadoc=*)
            __mvncomp "$(__mvnlist_jars)" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        packaging=*)
            __mvncomp "${__mvnpackaging}" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        *)
            local options="artifactId= classifier= file=press file=tab generatePom=true groupId= pomFile=press pomFile=tab
		  createChecksum=true url= version= sources=press sources=tab javadoc=press javadoc=tab";
            options="$options $(__mvnlist_prefix 'packaging=' ${__mvnpackaging} )";
            __mvncomp "$options" "-D" "${cur}"
        ;;
    esac
}
__mvnlist_goals () 
{ 
    local plugin=$1;
    local pfx="";
    if [[ -n "$2" ]]; then
        pfx=$2;
    fi;
    echo ${__mvnall_plugin_and_goals} | tr ' ' '\n' | grep --color=auto "$plugin" | sed "s/.*:/${pfx}/g"
}
__mvnlist_jars () 
{ 
    for x in `find -type f -name *.jar`;
    do
        echo ${x#./};
    done
}
__mvnlist_poms () 
{ 
    for x in `find -type f -name pom.xml -or -name *.pom`;
    do
        echo ${x#./};
    done
}
__mvnlist_prefix () 
{ 
    local pfx=$1 IFS=' ''	''
';
    shift;
    local list=$@;
    for c in $list;
    do
        echo "$pfx$c";
    done
}
__mvnlist_projects () 
{ 
    local poms=$(find . -name pom.xml -print);
    echo $poms | while read -d ' ' POM; do
        local DIR=$(dirname "$POM");
        if [[ "$DIR" != "." ]]; then
            echo "${DIR#./}";
        fi;
    done
}
__mvnplugin_help () 
{ 
    local plugin=$1;
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    case "${cur}" in 
        goal=*)
            __mvncomp "$(__mvnlist_goals $plugin)" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        *)
            __mvncomp "detail lineLength= indentSize= $(__mvnlist_goals $plugin 'goal=')" "-D" "${cur}"
        ;;
    esac
}
__mvnprefix_colon () 
{ 
    local cur=$1;
    local pfx="";
    case "$COMP_WORDBREAKS" in 
        *:*)
            : great
        ;;
        *)
            pfx="${cur%%:*}:"
        ;;
    esac;
    echo $pfx
}
__mvnprefix_comma () 
{ 
    local cur=$1;
    local pfx="";
    case "$COMP_WORDBREAKS" in 
        *,*)
            : great
        ;;
        *)
            pfx="${cur%%,*},"
        ;;
    esac;
    echo $pfx
}
__mvnprefix_equals () 
{ 
    local cur=$1;
    local pfx="";
    case "$COMP_WORDBREAKS" in 
        *=*)
            : great
        ;;
        *)
            pfx="${cur%%=*}="
        ;;
    esac;
    echo $pfx
}
__mvnrelease_prepare () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    __mvncomp "username= dryRun=true" "-D" "${cur}"
}
__mvnscm_checkin () 
{ 
    local versionType="branch tag revision";
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    case "${cur}" in 
        scmVersionType=*)
            __mvncomp "${versionType}" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        *)
            __mvncomp "username= message= passphrase= password= scmVersion= $(__mvnlist_prefix 'scmVersionType=' ${versionType})" "-D" "${cur}"
        ;;
    esac
}
__parse_options () 
{ 
    local option option2 i IFS=' 	
,/|';
    option=;
    for i in $1;
    do
        case $i in 
            ---*)
                break
            ;;
            --?*)
                option=$i;
                break
            ;;
            -?*)
                [[ -n $option ]] || option=$i
            ;;
            *)
                break
            ;;
        esac;
    done;
    [[ -n $option ]] || return 0;
    IFS=' 	
';
    if [[ $option =~ (\[((no|dont)-?)\]). ]]; then
        option2=${option/"${BASH_REMATCH[1]}"/};
        option2=${option2%%[<{().[]*};
        printf '%s\n' "${option2/=*/=}";
        option=${option/"${BASH_REMATCH[1]}"/"${BASH_REMATCH[2]}"};
    fi;
    option=${option%%[<{().[]*};
    printf '%s\n' "${option/=*/=}"
}
__ports () 
{ 
    pactl list cards 2> /dev/null | awk -e '/^\tPorts:/ {
            flag=1; next
         }

         /^\t[A-Za-z]/ {
             flag=0
         }

         flag {
             if (/^\t\t[A-Za-z]/)
                 ports = ports substr($0, 3, index($0, ":")-3) " "
         }

         END {
             print ports
         }'
}
__profiles () 
{ 
    pactl list cards 2> /dev/null | awk -e '/^\tProfiles:/ {
            flag=1; next
        }

        /^\t[A-Za-z]/ {
            flag=0
        }

        flag {
            if (/^\t\t[A-Za-z]/)
                profiles = profiles substr($0, 3, index($0, ": ")-3) " "
        }

        END {
            print profiles
        }'
}
__reassemble_comp_words_by_ref () 
{ 
    local exclude i j line ref;
    if [[ -n $1 ]]; then
        exclude="${1//[^$COMP_WORDBREAKS]}";
    fi;
    eval $3=$COMP_CWORD;
    if [[ -n $exclude ]]; then
        line=$COMP_LINE;
        for ((i=0, j=0; i < ${#COMP_WORDS[@]}; i++, j++))
        do
            while [[ $i -gt 0 && ${COMP_WORDS[$i]} == +([$exclude]) ]]; do
                [[ $line != [' 	']* ]] && (( j >= 2 )) && ((j--));
                ref="$2[$j]";
                eval $2[$j]=\${!ref}\${COMP_WORDS[i]};
                [[ $i == $COMP_CWORD ]] && eval $3=$j;
                line=${line#*"${COMP_WORDS[$i]}"};
                [[ $line == [' 	']* ]] && ((j++));
                (( $i < ${#COMP_WORDS[@]} - 1)) && ((i++)) || break 2;
            done;
            ref="$2[$j]";
            eval $2[$j]=\${!ref}\${COMP_WORDS[i]};
            line=${line#*"${COMP_WORDS[i]}"};
            [[ $i == $COMP_CWORD ]] && eval $3=$j;
        done;
        [[ $i == $COMP_CWORD ]] && eval $3=$j;
    else
        eval $2=\( \"\${COMP_WORDS[@]}\" \);
    fi
}
__resample_methods () 
{ 
    while read name; do
        printf "%s\n" "$name";
    done < <(pulseaudio --dump-resample-methods 2> /dev/null)
}
__sink_inputs () 
{ 
    while IFS='	' read idx _ _ _ _; do
        printf "%s\n" "$idx";
    done < <(pactl list sink-inputs short 2> /dev/null)
}
__sinks () 
{ 
    while IFS='	' read _ name _ _ _; do
        printf "%s\n" "$name";
    done < <(pactl list sinks short 2> /dev/null)
}
__sinks_idx () 
{ 
    while IFS='	' read idx _ _ _ _; do
        printf "%s\n" "$idx";
    done < <(pactl list sinks short 2> /dev/null)
}
__source_outputs () 
{ 
    while IFS='	' read idx _ _ _ _; do
        printf "%s\n" "$idx";
    done < <(pactl list source-outputs short 2> /dev/null)
}
__sources () 
{ 
    while IFS='	' read _ name _ _ _; do
        printf "%s\n" "$name";
    done < <(pactl list sources short 2> /dev/null)
}
_a2disconf () 
{ 
    local cur;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    _apache2_conf conf-enabled
}
_a2dismod () 
{ 
    local cur;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    _apache2_mods mods-enabled
}
_a2dissite () 
{ 
    local cur;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    _apache2_sites sites-enabled
}
_a2enconf () 
{ 
    local cur;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    _apache2_conf conf-available
}
_a2enmod () 
{ 
    local cur;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    _apache2_mods mods-available
}
_a2ensite () 
{ 
    local cur;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    _apache2_sites sites-available
}
_allowed_groups () 
{ 
    if _complete_as_root; then
        local IFS='
';
        COMPREPLY=($( compgen -g -- "$1" ));
    else
        local IFS='
 ';
        COMPREPLY=($( compgen -W             "$( id -Gn 2>/dev/null || groups 2>/dev/null )" -- "$1" ));
    fi
}
_allowed_users () 
{ 
    if _complete_as_root; then
        local IFS='
';
        COMPREPLY=($( compgen -u -- "${1:-$cur}" ));
    else
        local IFS='
 ';
        COMPREPLY=($( compgen -W             "$( id -un 2>/dev/null || whoami 2>/dev/null )" -- "${1:-$cur}" ));
    fi
}
_apache2_allcomp () 
{ 
    command ls /etc/apache2/$1 2> /dev/null
}
_apache2_conf () 
{ 
    COMPREPLY=($( compgen -W '$( _apache2_allcomp $1 \
               | sed -e 's/[.]conf$//' )' -- $cur  ))
}
_apache2_mods () 
{ 
    COMPREPLY=($( compgen -W '$( _apache2_allcomp $1 \
               | sed -e 's/[.]load$//' -e 's/[.]conf$//' )' -- $cur  ))
}
_apache2_sites () 
{ 
    COMPREPLY=($( compgen -W '$( _apache2_allcomp $1 )' -- $cur  ))
}
_apport-bug () 
{ 
    local cur dashoptions prev param;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    dashoptions='-h --help --save -v --version --tag -w --window';
    case "$prev" in 
        ubuntu-bug | apport-bug)
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
        --save)
            COMPREPLY=($( compgen -o default -G "$cur*" ))
        ;;
        -w | --window)
            dashoptions="--save --tag";
            COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
        ;;
        -h | --help | -v | --version | --tag)
            return 0
        ;;
        *)
            dashoptions="--tag";
            if ! [[ "${COMP_WORDS[*]}" =~ .*--save.* ]]; then
                dashoptions="--save $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--window.* || "${COMP_WORDS[*]}" =~ .*\ -w\ .* ]]; then
                dashoptions="-w --window $dashoptions";
            fi;
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
    esac
}
_apport-cli () 
{ 
    local cur dashoptions prev param;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    dashoptions='-h --help -f --file-bug -u --update-bug -s --symptom \
                 -c --crash-file --save -v --version --tag -w --window';
    case "$prev" in 
        apport-cli)
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
        -f | --file-bug)
            param="-P --pid -p --package -s --symptom";
            COMPREPLY=($( compgen -W "$param $(_apport_symptoms)" -- $cur))
        ;;
        -s | --symptom)
            COMPREPLY=($( compgen -W "$(_apport_symptoms)" -- $cur))
        ;;
        --save)
            COMPREPLY=($( compgen -o default -G "$cur*" ))
        ;;
        -c | --crash-file)
            COMPREPLY=($( compgen -G "${cur}*.apport"
                       compgen -G "${cur}*.crash" ))
        ;;
        -w | --window)
            dashoptions="--save --tag";
            COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
        ;;
        -h | --help | -v | --version | --tag)
            return 0
        ;;
        *)
            dashoptions='--tag';
            if ! [[ "${COMP_WORDS[*]}" =~ .*--save.* ]]; then
                dashoptions="--save $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--window.* || "${COMP_WORDS[*]}" =~ .*\ -w\ .* ]]; then
                dashoptions="-w --window $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--symptom.* || "${COMP_WORDS[*]}" =~ .*\ -s\ .* ]]; then
                dashoptions="-s --symptom $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--update.* || "${COMP_WORDS[*]}" =~ .*\ -u\ .* ]]; then
                dashoptions="-u --update $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--file-bug.* || "${COMP_WORDS[*]}" =~ .*\ -f\ .* ]]; then
                dashoptions="-f --file-bug $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--crash-file.* || "${COMP_WORDS[*]}" =~ .*\ -c\ .* ]]; then
                dashoptions="-c --crash-file $dashoptions";
            fi;
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
    esac
}
_apport-collect () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        apport-collect)
            COMPREPLY=($( compgen -W "-p --package --tag" -- $cur))
        ;;
        -p | --package)
            COMPREPLY=($( apt-cache pkgnames $cur 2> /dev/null ))
        ;;
        --tag)
            return 0
        ;;
        *)
            if [[ "${COMP_WORDS[*]}" =~ .*\ -p.* || "${COMP_WORDS[*]}" =~ .*--package.* ]]; then
                COMPREPLY=($( compgen -W "--tag" -- $cur));
            else
                COMPREPLY=($( compgen -W "-p --package --tag" -- $cur));
            fi
        ;;
    esac
}
_apport-unpack () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        apport-unpack)
            COMPREPLY=($( compgen -G "${cur}*.apport"
                       compgen -G "${cur}*.crash" ))
        ;;
    esac
}
_apport_parameterless () 
{ 
    local param;
    param="$dashoptions            $( apt-cache pkgnames $cur 2> /dev/null )            $( command ps axo pid | sed 1d )            $( _apport_symptoms )            $( compgen -G "${cur}*" )";
    COMPREPLY=($( compgen -W "$param" -- $cur))
}
_apport_symptoms () 
{ 
    local syms;
    if [ -r /usr/share/apport/symptoms ]; then
        for FILE in $(ls /usr/share/apport/symptoms);
        do
            if [[ ! "$FILE" =~ ^_.* && -n $(egrep "^def run\s*\(.*\):" /usr/share/apport/symptoms/$FILE) ]]; then
                syms="$syms ${FILE%.py}";
            fi;
        done;
    fi;
    echo $syms
}
_apt () 
{ 
    local cur opt;
    COMPREPLY=();
    cur="${COMP_WORDS[COMP_CWORD]}";
    if [[ $COMP_CWORD == 1 ]]; then
        COMPREPLY=($(compgen -W '\
        autoclean autoremove build build-dep changelog check clean \
        contains content deb depends dist-upgrade download \
        dselect-upgrade held help hold install policy purge rdepends \
        reinstall remove search show source sources unhold update \
        upgrade version' "$cur" ));
        return 0;
    fi;
    opt="${COMP_WORDS[1]}";
    case $opt in 
        "contains" | "search")
            _filedir;
            return 0
        ;;
        "deb")
            _filedir '?(u)deb';
            return 0
        ;;
        "build" | "build-dep" | "changelog" | "depends" | "download" | "install" | "policy" | "rdepends" | "show" | "source")
            COMPREPLY=($( apt-cache --no-generate pkgnames "$cur"         2> /dev/null ));
            return 0
        ;;
        "content" | "hold" | "purge" | "reinstall" | "remove" | "unhold" | "version")
            if [ -f /etc/debian_version ]; then
                COMPREPLY=($( _xfunc dpkg _comp_dpkg_installed_packages $cur ));
            else
                _xfunc rpm _rpm_installed_packages;
            fi;
            return 0
        ;;
    esac
}
_available_interfaces () 
{ 
    local cmd PATH=$PATH:/sbin;
    if [[ ${1:-} == -w ]]; then
        cmd="iwconfig";
    else
        if [[ ${1:-} == -a ]]; then
            cmd="{ ifconfig || ip link show up; }";
        else
            cmd="{ ifconfig -a || ip link show; }";
        fi;
    fi;
    COMPREPLY=($( eval $cmd 2>/dev/null | awk         '/^[^ \t]/ { if ($1 ~ /^[0-9]+:/) { print $2 } else { print $1 } }' ));
    COMPREPLY=($( compgen -W '${COMPREPLY[@]/%[[:punct:]]/}' -- "$cur" ))
}
_axi_cache () 
{ 
    local cur prev cmd;
    COMPREPLY=();
    COMP_WORDBREAKS=${COMP_WORDBREAKS//:};
    type _get_comp_words_by_ref &> /dev/null && { 
        _get_comp_words_by_ref -n: cur prev
    } || { 
        cur=$(_get_cword ":");
        prev=${COMP_WORDS[$COMP_CWORD-1]}
    };
    cmd=${COMP_WORDS[1]};
    case "$prev" in 
        *axi-cache*)
            COMPREPLY=($(compgen -W "help more search show again showpkg showsrc depends rdepends policy madison" -- "$cur"));
            return 0
        ;;
        --sort)
            COMPREPLY=($(compgen -W "$(egrep ^[a-z] /var/lib/apt-xapian-index/values | awk -F"\t" '{print $1}')" -- "$cur"));
            return 0
        ;;
    esac;
    case "$cmd" in 
        search | again)
            if [[ "$cur" == -* ]]; then
                COMPREPLY=($(compgen -W "--sort --tags" -- "$cur"));
                return 0;
            fi
        ;;
        show | showpkg | showsrc | depends | rdepends | policy | madison)
            if [[ "$cur" == -* ]]; then
                COMPREPLY=($(compgen -W "--last" -- "$cur"));
                return 0;
            fi
        ;;
        *)
            return 0
        ;;
    esac;
    if [ -n "$cur" ]; then
        COMPREPLY=($(compgen -W "$(${COMP_WORDS[@]} --tabcomplete=partial)" -- "$cur"));
    else
        COMPREPLY=($(compgen -W "$(${COMP_WORDS[@]} --tabcomplete=plain)" -- "$cur"));
    fi;
    return 0
}
_bwa () 
{ 
    local cur prev opts;
    COMPREPLY=();
    cur="${COMP_WORDS[COMP_CWORD]}";
    prev="${COMP_WORDS[COMP_CWORD-1]}";
    opts="index aln samse sampe
        bwasw fastmap mem fa2pac pac2bwt
        pac2bwtgen bwtupdate
        bwt2sa";
    case $prev in 
        bwa)
            COMPREPLY=($(compgen -W "${opts}" -- ${cur}))
        ;;
    esac;
    return 0
}
_cd () 
{ 
    local cur prev words cword;
    _init_completion || return;
    local IFS='
' i j k;
    compopt -o filenames;
    if [[ -z "${CDPATH:-}" || "$cur" == ?(.)?(.)/* ]]; then
        _filedir -d;
        return 0;
    fi;
    local -r mark_dirs=$(_rl_enabled mark-directories && echo y);
    local -r mark_symdirs=$(_rl_enabled mark-symlinked-directories && echo y);
    for i in ${CDPATH//:/'
'};
    do
        k="${#COMPREPLY[@]}";
        for j in $( compgen -d $i/$cur );
        do
            if [[ ( -n $mark_symdirs && -h $j || -n $mark_dirs && ! -h $j ) && ! -d ${j#$i/} ]]; then
                j+="/";
            fi;
            COMPREPLY[k++]=${j#$i/};
        done;
    done;
    _filedir -d;
    if [[ ${#COMPREPLY[@]} -eq 1 ]]; then
        i=${COMPREPLY[0]};
        if [[ "$i" == "$cur" && $i != "*/" ]]; then
            COMPREPLY[0]="${i}/";
        fi;
    fi;
    return 0
}
_cd_devices () 
{ 
    COMPREPLY+=($( compgen -f -d -X "!*/?([amrs])cd*" -- "${cur:-/dev/}" ))
}
_command () 
{ 
    local offset i;
    offset=1;
    for ((i=1; i <= COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            offset=$i;
            break;
        fi;
    done;
    _command_offset $offset
}
_command_offset () 
{ 
    local word_offset=$1 i j;
    for ((i=0; i < $word_offset; i++ ))
    do
        for ((j=0; j <= ${#COMP_LINE}; j++ ))
        do
            [[ "$COMP_LINE" == "${COMP_WORDS[i]}"* ]] && break;
            COMP_LINE=${COMP_LINE:1};
            ((COMP_POINT--));
        done;
        COMP_LINE=${COMP_LINE#"${COMP_WORDS[i]}"};
        ((COMP_POINT-=${#COMP_WORDS[i]}));
    done;
    for ((i=0; i <= COMP_CWORD - $word_offset; i++ ))
    do
        COMP_WORDS[i]=${COMP_WORDS[i+$word_offset]};
    done;
    for ((i; i <= COMP_CWORD; i++ ))
    do
        unset COMP_WORDS[i];
    done;
    ((COMP_CWORD -= $word_offset));
    COMPREPLY=();
    local cur;
    _get_comp_words_by_ref cur;
    if [[ $COMP_CWORD -eq 0 ]]; then
        local IFS='
';
        compopt -o filenames;
        COMPREPLY=($( compgen -d -c -- "$cur" ));
    else
        local cmd=${COMP_WORDS[0]} compcmd=${COMP_WORDS[0]};
        local cspec=$( complete -p $cmd 2>/dev/null );
        if [[ ! -n $cspec && $cmd == */* ]]; then
            cspec=$( complete -p ${cmd##*/} 2>/dev/null );
            [[ -n $cspec ]] && compcmd=${cmd##*/};
        fi;
        if [[ ! -n $cspec ]]; then
            compcmd=${cmd##*/};
            _completion_loader $compcmd;
            cspec=$( complete -p $compcmd 2>/dev/null );
        fi;
        if [[ -n $cspec ]]; then
            if [[ ${cspec#* -F } != $cspec ]]; then
                local func=${cspec#*-F };
                func=${func%% *};
                if [[ ${#COMP_WORDS[@]} -ge 2 ]]; then
                    $func $cmd "${COMP_WORDS[${#COMP_WORDS[@]}-1]}" "${COMP_WORDS[${#COMP_WORDS[@]}-2]}";
                else
                    $func $cmd "${COMP_WORDS[${#COMP_WORDS[@]}-1]}";
                fi;
                local opt;
                while [[ $cspec == *" -o "* ]]; do
                    cspec=${cspec#*-o };
                    opt=${cspec%% *};
                    compopt -o $opt;
                    cspec=${cspec#$opt};
                done;
            else
                cspec=${cspec#complete};
                cspec=${cspec%%$compcmd};
                COMPREPLY=($( eval compgen "$cspec" -- '$cur' ));
            fi;
        else
            if [[ ${#COMPREPLY[@]} -eq 0 ]]; then
                _minimal;
            fi;
        fi;
    fi
}
_complete_as_root () 
{ 
    [[ $EUID -eq 0 || -n ${root_command:-} ]]
}
_completion_loader () 
{ 
    local compfile=./completions;
    [[ $BASH_SOURCE == */* ]] && compfile="${BASH_SOURCE%/*}/completions";
    compfile+="/${1##*/}";
    [[ -f "$compfile" ]] && . "$compfile" &> /dev/null && return 124;
    complete -F _minimal "$1" && return 124
}
_configured_interfaces () 
{ 
    if [[ -f /etc/debian_version ]]; then
        COMPREPLY=($( compgen -W "$( sed -ne 's|^iface \([^ ]\{1,\}\).*$|\1|p'            /etc/network/interfaces )" -- "$cur" ));
    else
        if [[ -f /etc/SuSE-release ]]; then
            COMPREPLY=($( compgen -W "$( printf '%s\n'             /etc/sysconfig/network/ifcfg-* |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
        else
            if [[ -f /etc/pld-release ]]; then
                COMPREPLY=($( compgen -W "$( command ls -B             /etc/sysconfig/interfaces |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
            else
                COMPREPLY=($( compgen -W "$( printf '%s\n'             /etc/sysconfig/network-scripts/ifcfg-* |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
            fi;
        fi;
    fi
}
_count_args () 
{ 
    local i cword words;
    __reassemble_comp_words_by_ref "$1" words cword;
    args=1;
    for i in "${words[@]:1:cword-1}";
    do
        [[ "$i" != -* ]] && args=$(($args+1));
    done
}
_cryptdisks () 
{ 
    local tf;
    tf=${TABFILE-"/etc/crypttab"};
    COMPREPLY=($(egrep -v "^[[:space:]]*(#|$)" "${tf}" | egrep -o "^${COMP_WORDS[COMP_CWORD]}[^[:space:]]*"));
    return 0
}
_debconf_show () 
{ 
    local cur;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    COMPREPLY=($( compgen -W '--listowners --listdbs --db=' -- $cur ) $( apt-cache pkgnames -- $cur ))
}
_desktop_file_validate () 
{ 
    COMPRELY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    _filedir '@(desktop)'
}
_dkms () 
{ 
    local cur prev command module i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "add autoinstall remove build install uninstall 			match mkdriverdisk mktarball ldtarball mkrpm mkdeb mkdsc mkkmp 			status" -- $cur ));
    else
        prev=${COMP_WORDS[COMP_CWORD-1]};
        command=${COMP_WORDS[1]};
        case $prev in 
            -m)
                if [ "$command" = 'add' ]; then
                    _filename_parts '.*-.*' 1;
                else
                    _subdirectories /var/lib/dkms;
                fi;
                return 0
            ;;
            -v)
                for ((i=1; i < COMP_CWORD; i++ ))
                do
                    if [[ "${COMP_WORDS[i]}" == -m ]]; then
                        module=${COMP_WORDS[i+1]};
                        break;
                    fi;
                done;
                if [ -n "$module" ]; then
                    if [ "$command" = 'add' ]; then
                        _filename_parts "$module-.*" 2;
                    else
                        _subdirectories /var/lib/dkms/$module;
                    fi;
                    return 0;
                fi
            ;;
            -k)
                _kernels;
                return 0
            ;;
            -@\(c | -spec | -archive | -config\))
                _filedir;
                return 0
            ;;
            --kernelsourcedir)
                _filedir -d;
                return 0
            ;;
        esac;
        if [[ "$cur" == -* ]]; then
            case $command in 
                add)
                    options='-c --rpm_safe_upgrade'
                ;;
                remove)
                    options='--rpm_safe_upgrade'
                ;;
                build)
                    options='--config'
                ;;
                mkdriverdisk)
                    options='-d --distro -r --release --size'
                ;;
                ldtarball)
                    options='--archive --force'
                ;;
                mktarball)
                    options='--source-only --binaries-only'
                ;;
                mkrpm)
                    options='--source-only'
                ;;
                mkkmp)
                    options='--spec'
                ;;
                match)
                    options='--templatekernel'
                ;;
            esac;
            options="$options -m -v -k -a --arch -q --quiet -V 				--version --all --no-prepare-kernel 				--no-clean-kernel --kernelsourcedir 				--directive";
            COMPREPLY=($( compgen -W "$options" -- $cur ));
        fi;
    fi
}
_docker () 
{ 
    local previous_extglob_setting=$(shopt -p extglob);
    shopt -s extglob;
    local commands=(attach build commit cp create daemon diff events exec export history images import info inspect kill load login logout logs network pause port ps pull push rename restart rm rmi run save search start stats stop tag top unpause update version volume wait);
    local global_boolean_options="
		--debug -D
		--tls
		--tlsverify
	";
    local global_options_with_args="
		--config
		--host -H
		--log-level -l
		--tlscacert
		--tlscert
		--tlskey
	";
    local host config;
    COMPREPLY=();
    local cur prev words cword;
    _get_comp_words_by_ref -n : cur prev words cword;
    local command='docker' command_pos=0 subcommand_pos;
    local counter=1;
    while [ $counter -lt $cword ]; do
        case "${words[$counter]}" in 
            --host | -H)
                (( counter++ ));
                host="${words[$counter]}"
            ;;
            --config)
                (( counter++ ));
                config="${words[$counter]}"
            ;;
            $(__docker_to_extglob "$global_options_with_args"))
                (( counter++ ))
            ;;
            -*)

            ;;
            =)
                (( counter++ ))
            ;;
            *)
                command="${words[$counter]}";
                command_pos=$counter;
                break
            ;;
        esac;
        (( counter++ ));
    done;
    local completions_func=_docker_${command};
    declare -F $completions_func > /dev/null && $completions_func;
    eval "$previous_extglob_setting";
    return 0
}
_docker_attach () 
{ 
    __docker_complete_detach-keys && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--detach-keys --help --no-stdin --sig-proxy" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--detach-keys');
            if [ $cword -eq $counter ]; then
                __docker_complete_containers_running;
            fi
        ;;
    esac
}
_docker_build () 
{ 
    local options_with_args="
		--build-arg
		--cgroup-parent
		--cpuset-cpus
		--cpuset-mems
		--cpu-shares
		--cpu-period
		--cpu-quota
		--file -f
		--isolation
		--memory -m
		--memory-swap
		--shm-size
		--tag -t
		--ulimit
	";
    local boolean_options="
		--disable-content-trust=false
		--force-rm
		--help
		--no-cache
		--pull
		--quiet -q
		--rm
	";
    local all_options="$options_with_args $boolean_options";
    case "$prev" in 
        --build-arg)
            COMPREPLY=($( compgen -e -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --file | -f)
            _filedir;
            return
        ;;
        --isolation)
            __docker_complete_isolation;
            return
        ;;
        --tag | -t)
            __docker_complete_image_repos_and_tags;
            return
        ;;
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$all_options" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag $( __docker_to_alternatives "$options_with_args" ) );
            if [ $cword -eq $counter ]; then
                _filedir -d;
            fi
        ;;
    esac
}
_docker_commit () 
{ 
    case "$prev" in 
        --author | -a | --change | -c | --message | -m)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--author -a --change -c --help --message -m --pause -p" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--author|-a|--change|-c|--message|-m');
            if [ $cword -eq $counter ]; then
                __docker_complete_containers_all;
                return;
            fi;
            (( counter++ ));
            if [ $cword -eq $counter ]; then
                __docker_complete_image_repos_and_tags;
                return;
            fi
        ;;
    esac
}
_docker_cp () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--follow-link -L --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                case "$cur" in 
                    *:)
                        return
                    ;;
                    *)
                        _filedir;
                        local files=(${COMPREPLY[@]});
                        __docker_complete_containers_all;
                        COMPREPLY=($( compgen -W "${COMPREPLY[*]}" -S ':' ));
                        local containers=(${COMPREPLY[@]});
                        COMPREPLY=($( compgen -W "${files[*]} ${containers[*]}" -- "$cur" ));
                        if [[ "$COMPREPLY" == *: ]]; then
                            __docker_nospace;
                        fi;
                        return
                    ;;
                esac;
            fi;
            (( counter++ ));
            if [ $cword -eq $counter ]; then
                if [ -e "$prev" ]; then
                    __docker_complete_containers_all;
                    COMPREPLY=($( compgen -W "${COMPREPLY[*]}" -S ':' ));
                    __docker_nospace;
                else
                    _filedir;
                fi;
                return;
            fi
        ;;
    esac
}
_docker_create () 
{ 
    _docker_run
}
_docker_daemon () 
{ 
    local boolean_options="
		$global_boolean_options
		--disable-legacy-registry
		--help
		--icc=false
		--ip-forward=false
		--ip-masq=false
		--iptables=false
		--ipv6
		--selinux-enabled
		--userland-proxy=false
	";
    local options_with_args="
		$global_options_with_args
		--api-cors-header
		--authorization-plugin
		--bip
		--bridge -b
		--cgroup-parent
		--cluster-advertise
		--cluster-store
		--cluster-store-opt
		--default-gateway
		--default-gateway-v6
		--default-ulimit
		--dns
		--dns-search
		--dns-opt
		--exec-opt
		--exec-root
		--fixed-cidr
		--fixed-cidr-v6
		--graph -g
		--group -G
		--insecure-registry
		--ip
		--label
		--log-driver
		--log-opt
		--mtu
		--pidfile -p
		--registry-mirror
		--storage-driver -s
		--storage-opt
		--userns-remap
	";
    case "$prev" in 
        --authorization-plugin)
            __docker_complete_plugins Authorization;
            return
        ;;
        --cluster-store)
            COMPREPLY=($( compgen -W "consul etcd zk" -S "://" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --cluster-store-opt)
            COMPREPLY=($( compgen -W "discovery.heartbeat discovery.ttl kv.cacertfile kv.certfile kv.keyfile kv.path" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --exec-root | --graph | -g)
            _filedir -d;
            return
        ;;
        --log-driver)
            __docker_complete_log_drivers;
            return
        ;;
        --pidfile | -p | --tlscacert | --tlscert | --tlskey)
            _filedir;
            return
        ;;
        --storage-driver | -s)
            COMPREPLY=($( compgen -W "aufs btrfs devicemapper overlay vfs zfs" -- "$(echo $cur | tr '[:upper:]' '[:lower:]')" ));
            return
        ;;
        --storage-opt)
            local devicemapper_options="
				dm.basesize
				dm.blkdiscard
				dm.blocksize
				dm.fs
				dm.loopdatasize
				dm.loopmetadatasize
				dm.mkfsarg
				dm.mountopt
				dm.override_udev_sync_check
				dm.thinpooldev
				dm.use_deferred_deletion
				dm.use_deferred_removal
			";
            local zfs_options="zfs.fsname";
            case $(__docker_value_of_option '--storage-driver|-s') in 
                '')
                    COMPREPLY=($( compgen -W "$devicemapper_options $zfs_options" -S = -- "$cur" ))
                ;;
                devicemapper)
                    COMPREPLY=($( compgen -W "$devicemapper_options" -S = -- "$cur" ))
                ;;
                zfs)
                    COMPREPLY=($( compgen -W "$zfs_options" -S = -- "$cur" ))
                ;;
                *)
                    return
                ;;
            esac;
            __docker_nospace;
            return
        ;;
        --log-level | -l)
            __docker_complete_log_levels;
            return
        ;;
        --log-opt)
            __docker_complete_log_options;
            return
        ;;
        --userns-remap)
            if [[ $cur == *:* ]]; then
                COMPREPLY=($(compgen -g -- "${cur#*:}"));
            else
                COMPREPLY=($(compgen -u -S : -- "$cur"));
                __docker_nospace;
            fi;
            return
        ;;
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    __docker_complete_log_driver_options && return;
    case "${words[$cword-2]}$prev=" in 
        *dm.@(blkdiscard|override_udev_sync_check|use_deferred_@(removal|deletion))=*)
            COMPREPLY=($( compgen -W "false true" -- "${cur#=}" ));
            return
        ;;
        *dm.fs=*)
            COMPREPLY=($( compgen -W "ext4 xfs" -- "${cur#=}" ));
            return
        ;;
        *dm.thinpooldev=*)
            _filedir;
            return
        ;;
        *kv.*file=*)
            _filedir;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$boolean_options $options_with_args" -- "$cur" ))
        ;;
    esac
}
_docker_diff () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_docker () 
{ 
    local boolean_options="
		$global_boolean_options
		--help
		--version -v
	";
    case "$prev" in 
        --config)
            _filedir -d;
            return
        ;;
        --log-level | -l)
            __docker_complete_log_levels;
            return
        ;;
        $(__docker_to_extglob "$global_options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$boolean_options $global_options_with_args" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag $(__docker_to_extglob "$global_options_with_args") );
            if [ $cword -eq $counter ]; then
                COMPREPLY=($( compgen -W "${commands[*]} help" -- "$cur" ));
            fi
        ;;
    esac
}
_docker_events () 
{ 
    local filter=$(__docker_map_key_of_current_option '-f|--filter');
    case "$filter" in 
        container)
            cur="${cur##*=}";
            __docker_complete_containers_all;
            return
        ;;
        event)
            COMPREPLY=($( compgen -W "
				attach
				commit
				connect
				copy
				create
				delete
				destroy
				die
				disconnect
				exec_create
				exec_start
				export
				import
				kill
				mount
				oom
				pause
				pull
				push
				rename
				resize
				restart
				start
				stop
				tag
				top
				unmount
				unpause
				untag
				update
			" -- "${cur##*=}" ));
            return
        ;;
        image)
            cur="${cur##*=}";
            __docker_complete_images;
            return
        ;;
        network)
            cur="${cur##*=}";
            __docker_complete_networks;
            return
        ;;
        type)
            COMPREPLY=($( compgen -W "container image network volume" -- "${cur##*=}" ));
            return
        ;;
        volume)
            cur="${cur##*=}";
            __docker_complete_volumes;
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "container event image label network type volume" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --since | --until)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --help --since --until" -- "$cur" ))
        ;;
    esac
}
_docker_exec () 
{ 
    __docker_complete_detach-keys && return;
    case "$prev" in 
        --user | -u)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--detach -d --detach-keys --help --interactive -i --privileged -t --tty -u --user" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_running
        ;;
    esac
}
_docker_export () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_help () 
{ 
    local counter=$(__docker_pos_first_nonflag);
    if [ $cword -eq $counter ]; then
        COMPREPLY=($( compgen -W "${commands[*]}" -- "$cur" ));
    fi
}
_docker_history () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --no-trunc --quiet -q" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_images;
            fi
        ;;
    esac
}
_docker_images () 
{ 
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "dangling label" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "${words[$cword-2]}$prev=" in 
        *dangling=*)
            COMPREPLY=($( compgen -W "true false" -- "${cur#=}" ));
            return
        ;;
        *label=*)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--all -a --digests --filter -f --format --help --no-trunc --quiet -q" -- "$cur" ))
        ;;
        =)
            return
        ;;
        *)
            __docker_complete_image_repos
        ;;
    esac
}
_docker_import () 
{ 
    case "$prev" in 
        --change | -c | --message | -m)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--change -c --help --message -m" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--change|-c|--message|-m');
            if [ $cword -eq $counter ]; then
                return;
            fi;
            (( counter++ ));
            if [ $cword -eq $counter ]; then
                __docker_complete_image_repos_and_tags;
                return;
            fi
        ;;
    esac
}
_docker_info () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
    esac
}
_docker_inspect () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
        --type)
            COMPREPLY=($( compgen -W "image container" -- "$cur" ));
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help --size -s --type" -- "$cur" ))
        ;;
        *)
            case $(__docker_value_of_option --type) in 
                '')
                    __docker_complete_containers_and_images
                ;;
                container)
                    __docker_complete_containers_all
                ;;
                image)
                    __docker_complete_images
                ;;
            esac
        ;;
    esac
}
_docker_kill () 
{ 
    case "$prev" in 
        --signal | -s)
            __docker_complete_signals;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --signal -s" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_running
        ;;
    esac
}
_docker_load () 
{ 
    case "$prev" in 
        --input | -i)
            _filedir;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --input -i" -- "$cur" ))
        ;;
    esac
}
_docker_login () 
{ 
    case "$prev" in 
        --email | -e | --password | -p | --username | -u)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--email -e --help --password -p --username -u" -- "$cur" ))
        ;;
    esac
}
_docker_logout () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
    esac
}
_docker_logs () 
{ 
    case "$prev" in 
        --since | --tail)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--follow -f --help --since --tail --timestamps -t" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--tail');
            if [ $cword -eq $counter ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_network () 
{ 
    local subcommands="
		connect
		create
		disconnect
		inspect
		ls
		rm
	";
    __docker_subcommands "$subcommands" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_network_connect () 
{ 
    local options_with_args="
		--alias
		--ip
		--ip6
		--link
	";
    local boolean_options="
		--help
	";
    case "$prev" in 
        --link)
            case "$cur" in 
                *:*)

                ;;
                *)
                    __docker_complete_containers_running;
                    COMPREPLY=($( compgen -W "${COMPREPLY[*]}" -S ':' ));
                    __docker_nospace
                ;;
            esac;
            return
        ;;
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$boolean_options $options_with_args" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag $( __docker_to_alternatives "$options_with_args" ) );
            if [ $cword -eq $counter ]; then
                __docker_complete_networks;
            else
                if [ $cword -eq $(($counter + 1)) ]; then
                    __docker_complete_containers_all;
                fi;
            fi
        ;;
    esac
}
_docker_network_create () 
{ 
    case "$prev" in 
        --aux-address | --gateway | --ip-range | --ipam-opt | --opt | -o | --subnet)
            return
        ;;
        --ipam-driver)
            COMPREPLY=($( compgen -W "default" -- "$cur" ));
            return
        ;;
        --driver | -d)
            local plugins=" $(__docker_plugins Network) ";
            plugins=${plugins/ host / };
            plugins=${plugins/ null / };
            COMPREPLY=($(compgen -W "$plugins" -- "$cur"));
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--aux-address --driver -d --gateway --help --internal --ip-range --ipam-driver --ipam-opt --opt -o --subnet" -- "$cur" ))
        ;;
    esac
}
_docker_network_disconnect () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_networks;
            else
                if [ $cword -eq $(($counter + 1)) ]; then
                    __docker_complete_containers_in_network "$prev";
                fi;
            fi
        ;;
    esac
}
_docker_network_inspect () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_networks
        ;;
    esac
}
_docker_network_ls () 
{ 
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "id name type" -- "$cur" ));
            __docker_nospace;
            return
        ;;
    esac;
    case "${words[$cword-2]}$prev=" in 
        *id=*)
            cur="${cur#=}";
            __docker_complete_network_ids;
            return
        ;;
        *name=*)
            cur="${cur#=}";
            __docker_complete_network_names;
            return
        ;;
        *type=*)
            COMPREPLY=($( compgen -W "builtin custom" -- "${cur#=}" ));
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --help --no-trunc --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_network_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_networks
        ;;
    esac
}
_docker_pause () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_containers_pauseable;
            fi
        ;;
    esac
}
_docker_port () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_ps () 
{ 
    case "$prev" in 
        --before | --since)
            __docker_complete_containers_all
        ;;
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "ancestor exited id label name status" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format | -n)
            return
        ;;
    esac;
    case "${words[$cword-2]}$prev=" in 
        *ancestor=*)
            cur="${cur#=}";
            __docker_complete_images;
            return
        ;;
        *id=*)
            cur="${cur#=}";
            __docker_complete_container_ids;
            return
        ;;
        *name=*)
            cur="${cur#=}";
            __docker_complete_container_names;
            return
        ;;
        *status=*)
            COMPREPLY=($( compgen -W "created dead exited paused restarting running" -- "${cur#=}" ));
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--all -a --before --filter -f --format --help --latest -l -n --no-trunc --quiet -q --size -s --since" -- "$cur" ))
        ;;
    esac
}
_docker_pull () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--all-tags -a --disable-content-trust=false --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                for arg in "${COMP_WORDS[@]}";
                do
                    case "$arg" in 
                        --all-tags | -a)
                            __docker_complete_image_repos;
                            return
                        ;;
                    esac;
                done;
                __docker_complete_image_repos_and_tags;
            fi
        ;;
    esac
}
_docker_push () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--disable-content-trust=false --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_image_repos_and_tags;
            fi
        ;;
    esac
}
_docker_rename () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_restart () 
{ 
    case "$prev" in 
        --time | -t)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --time -t" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_all
        ;;
    esac
}
_docker_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help --link -l --volumes -v" -- "$cur" ))
        ;;
        *)
            for arg in "${COMP_WORDS[@]}";
            do
                case "$arg" in 
                    --force | -f)
                        __docker_complete_containers_all;
                        return
                    ;;
                esac;
            done;
            __docker_complete_containers_stopped
        ;;
    esac
}
_docker_rmi () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help --no-prune" -- "$cur" ))
        ;;
        *)
            __docker_complete_images
        ;;
    esac
}
_docker_run () 
{ 
    local options_with_args="
		--add-host
		--attach -a
		--blkio-weight
		--blkio-weight-device
		--cap-add
		--cap-drop
		--cgroup-parent
		--cidfile
		--cpu-period
		--cpu-quota
		--cpuset-cpus
		--cpuset-mems
		--cpu-shares
		--device
		--device-read-bps
		--device-read-iops
		--device-write-bps
		--device-write-iops
		--dns
		--dns-opt
		--dns-search
		--entrypoint
		--env -e
		--env-file
		--expose
		--group-add
		--hostname -h
		--ip
		--ip6
		--ipc
		--isolation
		--kernel-memory
		--label-file
		--label -l
		--link
		--log-driver
		--log-opt
		--mac-address
		--memory -m
		--memory-swap
		--memory-swappiness
		--memory-reservation
		--name
		--net
		--net-alias
		--oom-score-adj
		--pid
		--publish -p
		--restart
		--security-opt
		--shm-size
		--stop-signal
		--tmpfs
		--ulimit
		--user -u
		--uts
		--volume-driver
		--volumes-from
		--volume -v
		--workdir -w
	";
    local boolean_options="
		--disable-content-trust=false
		--help
		--interactive -i
		--oom-kill-disable
		--privileged
		--publish-all -P
		--read-only
		--tty -t
	";
    if [ "$command" = "run" ]; then
        options_with_args="$options_with_args
			--detach-keys
		";
        boolean_options="$boolean_options
			--detach -d
			--rm
			--sig-proxy=false
		";
        __docker_complete_detach-keys && return;
    fi;
    local all_options="$options_with_args $boolean_options";
    case "$prev" in 
        --add-host)
            case "$cur" in 
                *:)
                    __docker_complete_resolved_hostname;
                    return
                ;;
            esac
        ;;
        --attach | -a)
            COMPREPLY=($( compgen -W 'stdin stdout stderr' -- "$cur" ));
            return
        ;;
        --cap-add | --cap-drop)
            __docker_complete_capabilities;
            return
        ;;
        --cidfile | --env-file | --label-file)
            _filedir;
            return
        ;;
        --device | --tmpfs | --volume | -v)
            case "$cur" in 
                *:*)

                ;;
                '')
                    COMPREPLY=($( compgen -W '/' -- "$cur" ));
                    __docker_nospace
                ;;
                /*)
                    _filedir;
                    __docker_nospace
                ;;
            esac;
            return
        ;;
        --env | -e)
            COMPREPLY=($( compgen -e -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --ipc)
            case "$cur" in 
                *:*)
                    cur="${cur#*:}";
                    __docker_complete_containers_running
                ;;
                *)
                    COMPREPLY=($( compgen -W 'host container:' -- "$cur" ));
                    if [ "$COMPREPLY" = "container:" ]; then
                        __docker_nospace;
                    fi
                ;;
            esac;
            return
        ;;
        --isolation)
            __docker_complete_isolation;
            return
        ;;
        --link)
            case "$cur" in 
                *:*)

                ;;
                *)
                    __docker_complete_containers_running;
                    COMPREPLY=($( compgen -W "${COMPREPLY[*]}" -S ':' ));
                    __docker_nospace
                ;;
            esac;
            return
        ;;
        --log-driver)
            __docker_complete_log_drivers;
            return
        ;;
        --log-opt)
            __docker_complete_log_options;
            return
        ;;
        --net)
            case "$cur" in 
                container:*)
                    local cur=${cur#*:};
                    __docker_complete_containers_all
                ;;
                *)
                    COMPREPLY=($( compgen -W "$(__docker_plugins Network) $(__docker_networks) container:" -- "$cur"));
                    if [ "${COMPREPLY[*]}" = "container:" ]; then
                        __docker_nospace;
                    fi
                ;;
            esac;
            return
        ;;
        --restart)
            case "$cur" in 
                on-failure:*)

                ;;
                *)
                    COMPREPLY=($( compgen -W "always no on-failure on-failure: unless-stopped" -- "$cur"))
                ;;
            esac;
            return
        ;;
        --security-opt)
            case "$cur" in 
                label:*:*)

                ;;
                label:*)
                    local cur=${cur##*:};
                    COMPREPLY=($( compgen -W "user: role: type: level: disable" -- "$cur"));
                    if [ "${COMPREPLY[*]}" != "disable" ]; then
                        __docker_nospace;
                    fi
                ;;
                seccomp:*)
                    local cur=${cur##*:};
                    _filedir;
                    COMPREPLY+=($( compgen -W "unconfined" -- "$cur" ))
                ;;
                *)
                    COMPREPLY=($( compgen -W "label apparmor seccomp" -S ":" -- "$cur"));
                    __docker_nospace
                ;;
            esac;
            return
        ;;
        --volume-driver)
            __docker_complete_plugins Volume;
            return
        ;;
        --volumes-from)
            __docker_complete_containers_all;
            return
        ;;
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    __docker_complete_log_driver_options && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$all_options" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag $( __docker_to_alternatives "$options_with_args" ) );
            if [ $cword -eq $counter ]; then
                __docker_complete_images;
            fi
        ;;
    esac
}
_docker_save () 
{ 
    case "$prev" in 
        --output | -o)
            _filedir;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --output -o" -- "$cur" ))
        ;;
        *)
            __docker_complete_images
        ;;
    esac
}
_docker_search () 
{ 
    case "$prev" in 
        --stars | -s)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--automated --help --no-trunc --stars -s" -- "$cur" ))
        ;;
    esac
}
_docker_start () 
{ 
    __docker_complete_detach-keys && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--attach -a --detach-keys --help --interactive -i" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_stopped
        ;;
    esac
}
_docker_stats () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--all -a --help --no-stream" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_running
        ;;
    esac
}
_docker_stop () 
{ 
    case "$prev" in 
        --time | -t)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --time -t" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_running
        ;;
    esac
}
_docker_tag () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_image_repos_and_tags;
                return;
            fi;
            (( counter++ ));
            if [ $cword -eq $counter ]; then
                __docker_complete_image_repos_and_tags;
                return;
            fi
        ;;
    esac
}
_docker_top () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_containers_running;
            fi
        ;;
    esac
}
_docker_unpause () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_containers_unpauseable;
            fi
        ;;
    esac
}
_docker_update () 
{ 
    local options_with_args="
		--blkio-weight
		--cpu-period
		--cpu-quota
		--cpuset-cpus
		--cpuset-mems
		--cpu-shares
		--kernel-memory
		--memory -m
		--memory-reservation
		--memory-swap
	";
    local boolean_options="
		--help
	";
    local all_options="$options_with_args $boolean_options";
    case "$prev" in 
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$all_options" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_all
        ;;
    esac
}
_docker_version () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
    esac
}
_docker_volume () 
{ 
    local subcommands="
		create
		inspect
		ls
		rm
	";
    __docker_subcommands "$subcommands" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_volume_create () 
{ 
    case "$prev" in 
        --driver | -d)
            __docker_complete_plugins Volume;
            return
        ;;
        --name | --opt | -o)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--driver -d --help --name --opt -o" -- "$cur" ))
        ;;
    esac
}
_docker_volume_inspect () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_volumes
        ;;
    esac
}
_docker_volume_ls () 
{ 
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "dangling" -- "$cur" ));
            __docker_nospace;
            return
        ;;
    esac;
    case "${words[$cword-2]}$prev=" in 
        *dangling=*)
            COMPREPLY=($( compgen -W "true false" -- "${cur#=}" ));
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --help --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_volume_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_volumes
        ;;
    esac
}
_docker_wait () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_all
        ;;
    esac
}
_dvd_devices () 
{ 
    COMPREPLY+=($( compgen -f -d -X "!*/?(r)dvd*" -- "${cur:-/dev/}" ))
}
_expand () 
{ 
    if [[ "$cur" == \~*/* ]]; then
        eval cur=$cur 2> /dev/null;
    else
        if [[ "$cur" == \~* ]]; then
            cur=${cur#\~};
            COMPREPLY=($( compgen -P '~' -u "$cur" ));
            [[ ${#COMPREPLY[@]} -eq 1 ]] && eval COMPREPLY[0]=${COMPREPLY[0]};
            return ${#COMPREPLY[@]};
        fi;
    fi
}
_filedir () 
{ 
    local i IFS='
' xspec;
    _tilde "$cur" || return 0;
    local -a toks;
    local quoted x tmp;
    _quote_readline_by_ref "$cur" quoted;
    x=$( compgen -d -- "$quoted" ) && while read -r tmp; do
        toks+=("$tmp");
    done <<< "$x";
    if [[ "$1" != -d ]]; then
        xspec=${1:+"!*.@($1|${1^^})"};
        x=$( compgen -f -X "$xspec" -- $quoted ) && while read -r tmp; do
            toks+=("$tmp");
        done <<< "$x";
    fi;
    [[ -n ${COMP_FILEDIR_FALLBACK:-} && -n "$1" && "$1" != -d && ${#toks[@]} -lt 1 ]] && x=$( compgen -f -- $quoted ) && while read -r tmp; do
        toks+=("$tmp");
    done <<< "$x";
    if [[ ${#toks[@]} -ne 0 ]]; then
        compopt -o filenames 2> /dev/null;
        COMPREPLY+=("${toks[@]}");
    fi
}
_filedir_xspec () 
{ 
    local cur prev words cword;
    _init_completion || return;
    _tilde "$cur" || return 0;
    local IFS='
' xspec=${_xspecs[${1##*/}]} tmp;
    local -a toks;
    toks=($(
        compgen -d -- "$(quote_readline "$cur")" | {
        while read -r tmp; do
            printf '%s\n' $tmp
        done
        }
        ));
    eval xspec="${xspec}";
    local matchop=!;
    if [[ $xspec == !* ]]; then
        xspec=${xspec#!};
        matchop=@;
    fi;
    xspec="$matchop($xspec|${xspec^^})";
    toks+=($(
        eval compgen -f -X "!$xspec" -- "\$(quote_readline "\$cur")" | {
        while read -r tmp; do
            [[ -n $tmp ]] && printf '%s\n' $tmp
        done
        }
        ));
    if [[ ${#toks[@]} -ne 0 ]]; then
        compopt -o filenames;
        COMPREPLY=("${toks[@]}");
    fi
}
_filename_parts () 
{ 
    COMPREPLY=($( command ls -F /usr/src/ 2>/dev/null | grep -E '^'$1'/$' 		| sed -r -e 's/^([^-]+)-(.+)\/$/\'$2'/' | grep "^$cur" ))
}
_fstypes () 
{ 
    local fss;
    if [[ -e /proc/filesystems ]]; then
        fss="$( cut -d'	' -f2 /proc/filesystems )
             $( awk '! /\*/ { print $NF }' /etc/filesystems 2>/dev/null )";
    else
        fss="$( awk '/^[ \t]*[^#]/ { print $3 }' /etc/fstab 2>/dev/null )
             $( awk '/^[ \t]*[^#]/ { print $3 }' /etc/mnttab 2>/dev/null )
             $( awk '/^[ \t]*[^#]/ { print $4 }' /etc/vfstab 2>/dev/null )
             $( awk '{ print $1 }' /etc/dfs/fstypes 2>/dev/null )
             $( [[ -d /etc/fs ]] && command ls /etc/fs )";
    fi;
    [[ -n $fss ]] && COMPREPLY+=($( compgen -W "$fss" -- "$cur" ))
}
_get_comp_words_by_ref () 
{ 
    local exclude flag i OPTIND=1;
    local cur cword words=();
    local upargs=() upvars=() vcur vcword vprev vwords;
    while getopts "c:i:n:p:w:" flag "$@"; do
        case $flag in 
            c)
                vcur=$OPTARG
            ;;
            i)
                vcword=$OPTARG
            ;;
            n)
                exclude=$OPTARG
            ;;
            p)
                vprev=$OPTARG
            ;;
            w)
                vwords=$OPTARG
            ;;
        esac;
    done;
    while [[ $# -ge $OPTIND ]]; do
        case ${!OPTIND} in 
            cur)
                vcur=cur
            ;;
            prev)
                vprev=prev
            ;;
            cword)
                vcword=cword
            ;;
            words)
                vwords=words
            ;;
            *)
                echo "bash: $FUNCNAME(): \`${!OPTIND}': unknown argument" 1>&2;
                return 1
            ;;
        esac;
        let "OPTIND += 1";
    done;
    __get_cword_at_cursor_by_ref "$exclude" words cword cur;
    [[ -n $vcur ]] && { 
        upvars+=("$vcur");
        upargs+=(-v $vcur "$cur")
    };
    [[ -n $vcword ]] && { 
        upvars+=("$vcword");
        upargs+=(-v $vcword "$cword")
    };
    [[ -n $vprev && $cword -ge 1 ]] && { 
        upvars+=("$vprev");
        upargs+=(-v $vprev "${words[cword - 1]}")
    };
    [[ -n $vwords ]] && { 
        upvars+=("$vwords");
        upargs+=(-a${#words[@]} $vwords "${words[@]}")
    };
    (( ${#upvars[@]} )) && local "${upvars[@]}" && _upvars "${upargs[@]}"
}
_get_cword () 
{ 
    local LC_CTYPE=C;
    local cword words;
    __reassemble_comp_words_by_ref "$1" words cword;
    if [[ -n ${2//[^0-9]/} ]]; then
        printf "%s" "${words[cword-$2]}";
    else
        if [[ "${#words[cword]}" -eq 0 || "$COMP_POINT" == "${#COMP_LINE}" ]]; then
            printf "%s" "${words[cword]}";
        else
            local i;
            local cur="$COMP_LINE";
            local index="$COMP_POINT";
            for ((i = 0; i <= cword; ++i ))
            do
                while [[ "${#cur}" -ge ${#words[i]} && "${cur:0:${#words[i]}}" != "${words[i]}" ]]; do
                    cur="${cur:1}";
                    ((index--));
                done;
                if [[ "$i" -lt "$cword" ]]; then
                    local old_size="${#cur}";
                    cur="${cur#${words[i]}}";
                    local new_size="${#cur}";
                    index=$(( index - old_size + new_size ));
                fi;
            done;
            if [[ "${words[cword]:0:${#cur}}" != "$cur" ]]; then
                printf "%s" "${words[cword]}";
            else
                printf "%s" "${cur:0:$index}";
            fi;
        fi;
    fi
}
_get_first_arg () 
{ 
    local i;
    arg=;
    for ((i=1; i < COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            arg=${COMP_WORDS[i]};
            break;
        fi;
    done
}
_get_pword () 
{ 
    if [[ $COMP_CWORD -ge 1 ]]; then
        _get_cword "${@:-}" 1;
    fi
}
_gids () 
{ 
    if type getent &> /dev/null; then
        COMPREPLY=($( compgen -W '$( getent group | cut -d: -f3 )'             -- "$cur" ));
    else
        if type perl &> /dev/null; then
            COMPREPLY=($( compgen -W '$( perl -e '"'"'while (($gid) = (getgrent)[2]) { print $gid . "\n" }'"'"' )' -- "$cur" ));
        else
            COMPREPLY=($( compgen -W '$( cut -d: -f3 /etc/group )' -- "$cur" ));
        fi;
    fi
}
_grub_editenv () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        create | list | set | unset)
            COMPREPLY=("");
            return
        ;;
    esac;
    __grubcomp "$(__grub_get_options_from_help)
                create list set unset"
}
_grub_install () 
{ 
    local cur prev last split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    last=$(__grub_get_last_option);
    _split_longopt && split=true;
    case "$prev" in 
        --boot-directory)
            _filedir -d;
            return
        ;;
        --disk-module)
            __grubcomp "biosdisk ata";
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        case "$last" in 
            --modules)
                __grub_list_modules;
                return
            ;;
        esac;
        _filedir;
    fi
}
_grub_mkconfig () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_mkfont () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_mkimage () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        -d | --directory | -p | --prefix)
            _filedir -d;
            return
        ;;
        -O | --format)
            local prog=${COMP_WORDS[0]};
            __grubcomp "$(LC_ALL=C $prog --help |                         awk -F ":" '/available formats/ { print $2 }' |                         sed 's/, / /g')";
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_mkpasswd_pbkdf2 () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_mkrescue () 
{ 
    local cur prev last;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    last=$(__grub_get_last_option);
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        case "$last" in 
            --modules)
                __grub_list_modules;
                return
            ;;
        esac;
        _filedir;
    fi
}
_grub_probe () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        -t | --target)
            local prog=${COMP_WORDS[0]};
            __grubcomp "$(LC_ALL=C $prog --help |                         awk -F "[()]" '/--target=/ { print $2 }' |                         sed 's/|/ /g')";
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_script_check () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_set_entry () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        --boot-directory)
            _filedir -d;
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        __grub_list_menuentries;
    fi
}
_grub_setup () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        -d | --directory)
            _filedir -d;
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_have () 
{ 
    PATH=$PATH:/usr/sbin:/sbin:/usr/local/sbin type $1 &> /dev/null
}
_init_completion () 
{ 
    local exclude= flag outx errx inx OPTIND=1;
    while getopts "n:e:o:i:s" flag "$@"; do
        case $flag in 
            n)
                exclude+=$OPTARG
            ;;
            e)
                errx=$OPTARG
            ;;
            o)
                outx=$OPTARG
            ;;
            i)
                inx=$OPTARG
            ;;
            s)
                split=false;
                exclude+==
            ;;
        esac;
    done;
    COMPREPLY=();
    local redir="@(?([0-9])<|?([0-9&])>?(>)|>&)";
    _get_comp_words_by_ref -n "$exclude<>&" cur prev words cword;
    _variables && return 1;
    if [[ $cur == $redir* || $prev == $redir ]]; then
        local xspec;
        case $cur in 
            2'>'*)
                xspec=$errx
            ;;
            *'>'*)
                xspec=$outx
            ;;
            *'<'*)
                xspec=$inx
            ;;
            *)
                case $prev in 
                    2'>'*)
                        xspec=$errx
                    ;;
                    *'>'*)
                        xspec=$outx
                    ;;
                    *'<'*)
                        xspec=$inx
                    ;;
                esac
            ;;
        esac;
        cur="${cur##$redir}";
        _filedir $xspec;
        return 1;
    fi;
    local i skip;
    for ((i=1; i < ${#words[@]}; 1))
    do
        if [[ ${words[i]} == $redir* ]]; then
            [[ ${words[i]} == $redir ]] && skip=2 || skip=1;
            words=("${words[@]:0:i}" "${words[@]:i+skip}");
            [[ $i -le $cword ]] && cword=$(( cword - skip ));
        else
            i=$(( ++i ));
        fi;
    done;
    [[ $cword -le 0 ]] && return 1;
    prev=${words[cword-1]};
    [[ -n ${split-} ]] && _split_longopt && split=true;
    return 0
}
_inkscape () 
{ 
    local cur;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-? --help --usage -V --version \
			-z --without-gui -g --with-gui -f --file= -p --print= \
			-e --export-png= -d --export-dpi= -a --export-area= \
			-w --export-width= -h --export-height= -i --export-id= \
			-j --export-id-only  -t --export-use-hints -b --export-background= \
			-y --export-background-opacity= -l --export-plain-svg= -s --slideshow' -- $cur ));
    else
        _filedir '@(ai|ani|bmp|cur|dia|eps|gif|ggr|ico|jpe|jpeg|jpg|pbm|pcx|pdf|pgm|png|ppm|pnm|ps|ras|sk|svg|svgz|targa|tga|tif|tiff|txt|wbmp|wmf|xbm|xpm)';
    fi
}
_installed_modules () 
{ 
    COMPREPLY=($( compgen -W "$( PATH="$PATH:/sbin" lsmod |         awk '{if (NR != 1) print $1}' )" -- "$1" ))
}
_ip_addresses () 
{ 
    local PATH=$PATH:/sbin;
    COMPREPLY+=($( compgen -W         "$( { LC_ALL=C ifconfig -a || ip addr show; } 2>/dev/null |
            sed -ne 's/.*addr:\([^[:space:]]*\).*/\1/p'                 -ne 's|.*inet[[:space:]]\{1,\}\([^[:space:]/]*\).*|\1|p' )"         -- "$cur" ))
}
_kernel_versions () 
{ 
    COMPREPLY=($( compgen -W '$( command ls /lib/modules )' -- "$cur" ))
}
_kernels () 
{ 
    COMPREPLY=($( cd /lib/modules && compgen -d -- "$cur" ))
}
_known_hosts () 
{ 
    local cur prev words cword;
    _init_completion -n : || return;
    local options;
    [[ "$1" == -a || "$2" == -a ]] && options=-a;
    [[ "$1" == -c || "$2" == -c ]] && options+=" -c";
    _known_hosts_real $options -- "$cur"
}
_known_hosts_real () 
{ 
    local configfile flag prefix;
    local cur curd awkcur user suffix aliases i host;
    local -a kh khd config;
    local OPTIND=1;
    while getopts "acF:p:" flag "$@"; do
        case $flag in 
            a)
                aliases='yes'
            ;;
            c)
                suffix=':'
            ;;
            F)
                configfile=$OPTARG
            ;;
            p)
                prefix=$OPTARG
            ;;
        esac;
    done;
    [[ $# -lt $OPTIND ]] && echo "error: $FUNCNAME: missing mandatory argument CWORD";
    cur=${!OPTIND};
    let "OPTIND += 1";
    [[ $# -ge $OPTIND ]] && echo "error: $FUNCNAME("$@"): unprocessed arguments:" $(while [[ $# -ge $OPTIND ]]; do printf '%s\n' ${!OPTIND}; shift; done);
    [[ $cur == *@* ]] && user=${cur%@*}@ && cur=${cur#*@};
    kh=();
    if [[ -n $configfile ]]; then
        [[ -r $configfile ]] && config+=("$configfile");
    else
        for i in /etc/ssh/ssh_config ~/.ssh/config ~/.ssh2/config;
        do
            [[ -r $i ]] && config+=("$i");
        done;
    fi;
    if [[ ${#config[@]} -gt 0 ]]; then
        local OIFS=$IFS IFS='
' j;
        local -a tmpkh;
        tmpkh=($( awk 'sub("^[ \t]*([Gg][Ll][Oo][Bb][Aa][Ll]|[Uu][Ss][Ee][Rr])[Kk][Nn][Oo][Ww][Nn][Hh][Oo][Ss][Tt][Ss][Ff][Ii][Ll][Ee][ \t]+", "") { print $0 }' "${config[@]}" | sort -u ));
        IFS=$OIFS;
        for i in "${tmpkh[@]}";
        do
            while [[ $i =~ ^([^\"]*)\"([^\"]*)\"(.*)$ ]]; do
                i=${BASH_REMATCH[1]}${BASH_REMATCH[3]};
                j=${BASH_REMATCH[2]};
                __expand_tilde_by_ref j;
                [[ -r $j ]] && kh+=("$j");
            done;
            for j in $i;
            do
                __expand_tilde_by_ref j;
                [[ -r $j ]] && kh+=("$j");
            done;
        done;
    fi;
    if [[ -z $configfile ]]; then
        for i in /etc/ssh/ssh_known_hosts /etc/ssh/ssh_known_hosts2 /etc/known_hosts /etc/known_hosts2 ~/.ssh/known_hosts ~/.ssh/known_hosts2;
        do
            [[ -r $i ]] && kh+=("$i");
        done;
        for i in /etc/ssh2/knownhosts ~/.ssh2/hostkeys;
        do
            [[ -d $i ]] && khd+=("$i"/*pub);
        done;
    fi;
    if [[ ${#kh[@]} -gt 0 || ${#khd[@]} -gt 0 ]]; then
        awkcur=${cur//\//\\\/};
        awkcur=${awkcur//\./\\\.};
        curd=$awkcur;
        if [[ "$awkcur" == [0-9]*[.:]* ]]; then
            awkcur="^$awkcur[.:]*";
        else
            if [[ "$awkcur" == [0-9]* ]]; then
                awkcur="^$awkcur.*[.:]";
            else
                if [[ -z $awkcur ]]; then
                    awkcur="[a-z.:]";
                else
                    awkcur="^$awkcur";
                fi;
            fi;
        fi;
        if [[ ${#kh[@]} -gt 0 ]]; then
            COMPREPLY+=($( awk 'BEGIN {FS=","}
            /^\s*[^|\#]/ {
            sub("^@[^ ]+ +", ""); \
            sub(" .*$", ""); \
            for (i=1; i<=NF; ++i) { \
            sub("^\\[", "", $i); sub("\\](:[0-9]+)?$", "", $i); \
            if ($i !~ /[*?]/ && $i ~ /'"$awkcur"'/) {print $i} \
            }}' "${kh[@]}" 2>/dev/null ));
        fi;
        if [[ ${#khd[@]} -gt 0 ]]; then
            for i in "${khd[@]}";
            do
                if [[ "$i" == *key_22_$curd*.pub && -r "$i" ]]; then
                    host=${i/#*key_22_/};
                    host=${host/%.pub/};
                    COMPREPLY+=($host);
                fi;
            done;
        fi;
        for ((i=0; i < ${#COMPREPLY[@]}; i++ ))
        do
            COMPREPLY[i]=$prefix$user${COMPREPLY[i]}$suffix;
        done;
    fi;
    if [[ ${#config[@]} -gt 0 && -n "$aliases" ]]; then
        local hosts=$( sed -ne 's/^[ \t]*[Hh][Oo][Ss][Tt]\([Nn][Aa][Mm][Ee]\)\{0,1\}['"$'\t '"']\{1,\}\([^#*?]*\)\(#.*\)\{0,1\}$/\2/p' "${config[@]}" );
        COMPREPLY+=($( compgen -P "$prefix$user"             -S "$suffix" -W "$hosts" -- "$cur" ));
    fi;
    COMPREPLY+=($( compgen -W         "$( ruptime 2>/dev/null | awk '!/^ruptime:/ { print $1 }' )"         -- "$cur" ));
    if [[ -n ${COMP_KNOWN_HOSTS_WITH_HOSTFILE-1} ]]; then
        COMPREPLY+=($( compgen -A hostname -P "$prefix$user" -S "$suffix" -- "$cur" ));
    fi;
    __ltrim_colon_completions "$prefix$user$cur";
    return 0
}
_loexp_ () 
{ 
    local c=${COMP_WORDS[COMP_CWORD]};
    local a="${COMP_LINE}";
    local e s g=0 cd dc t="";
    local IFS;
    shopt -q extglob && g=1;
    test $g -eq 0 && shopt -s extglob;
    cd='*-?(c)d*';
    dc='*-d?(c)*';
    case "${1##*/}" in 
        lowriter)
            e='!*.+(doc|DOC|dot|DOT|rtf|RTF|sxw|SXW|stw|STW|sdw|SDW|vor|VOR|txt|TXT|htm?|HTM?|xml|XML|wp|WP|wpd|WPD|wps|WPS|odt|ODT|ott|OTT|fodt|FODT|docm|DOCM|docx|DOCX|dotm|DOTM|dotx|DOTX|sxg|SXG|odm|ODM|sgl|SGL)'
        ;;
        lobase)
            e='!*.+(odb|ODB)'
        ;;
        lodraw)
            e='!*.+(sxd|SXD|std|STD|dxf|DXF|emf|EMF|eps|EPS|met|MET|pct|PCT|sgf|SGF|sgv|SGV|sda|SDA|sdd|SDD|vor|VOR|svm|SVM|wmf|WMF|bmp|BMP|gif|GIF|jpg|JPG|jpeg|JPEG|jfif|JFIF|fif|FIF|jpe|JPE|pcd|PCD|pcx|PCX|pgm|PGM|png|PNG|ppm|PPM|psd|PSD|ras|RAS|tga|TGA|tif|TIF|tiff|TIFF|xbm|XBM|xpm|XPM|odg|ODG|otg|OTG|fodg|FODG|odc|ODC|odi|ODI|sds|SDS|wpg|WPG|svg|SVG|vdx|VDX|vsd|VSD|vsdm|VSDM|vsdx|VSDX)'
        ;;
        loffice)
            e='!*.+(sxd|SXD|std|STD|dxf|DXF|emf|EMF|eps|EPS|met|MET|pct|PCT|sgf|SGF|sgv|SGV|sda|SDA|sdd|SDD|vor|VOR|svm|SVM|wmf|WMF|bmp|BMP|gif|GIF|jpg|JPG|jpeg|JPEG|jfif|JFIF|fif|FIF|jpe|JPE|pcd|PCD|pcx|PCX|pgm|PGM|png|PNG|ppm|PPM|psd|PSD|ras|RAS|tga|TGA|tif|TIF|tiff|TIFF|xbm|XBM|xpm|XPM|odg|ODG|otg|OTG|fodg|FODG|odc|ODC|odi|ODI|sds|SDS|wpg|WPG|svg|SVG|vdx|VDX|vsd|VSD|vsdm|VSDM|vsdx|VSDX|doc|DOC|dot|DOT|rtf|RTF|sxw|SXW|stw|STW|sdw|SDW|vor|VOR|txt|TXT|htm?|HTM?|xml|XML|wp|WP|wpd|WPD|wps|WPS|odt|ODT|ott|OTT|fodt|FODT|docm|DOCM|docx|DOCX|dotm|DOTM|dotx|DOTX|sxm|SXM|smf|SMF|mml|MML|odf|ODF|sxi|SXI|sti|STI|ppt|PPT|pps|PPS|pot|POT|sxd|SXD|sda|SDA|sdd|SDD|sdp|SDP|vor|VOR|cgm|CGM|odp|ODP|otp|OTP|fodp|FODP|ppsm|PPSM|ppsx|PPSX|pptm|PPTM|pptx|PPTX|potm|POTM|potx|POTX|odb|ODB|sxc|SXC|stc|STC|dif|DIF|dbf|DBF|xls|XLS|xlw|XLW|xlt|XLT|rtf|RTF|sdc|SDC|vor|VOR|slk|SLK|txt|TXT|htm|HTM|html|HTML|wk1|WK1|wks|WKS|123|123|xml|XML|ods|ODS|ots|OTS|fods|FODS|csv|CSV|xlsb|XLSB|xlsm|XLSM|xlsx|XLSX|xltm|XLTM|xltx|XLTX|sxg|SXG|odm|ODM|sgl|SGL|stw|STW|dot|DOT|vor|VOR|stc|STC|xlt|XLT|sti|STI|pot|POT|std|STD|stw|STW|dotm|DOTM|dotx|DOTX|potm|POTM|potx|POTX|xltm|XLTM|xltx|XLTX|htm|HTM|html|HTML|stw|STW|txt|TXT|vor|VOR|oth|OTH)'
        ;;
        unopkg)
            e='!*.+(oxt|OXT)'
        ;;
        libreoffice)
            e='!*.+(sxd|SXD|std|STD|dxf|DXF|emf|EMF|eps|EPS|met|MET|pct|PCT|sgf|SGF|sgv|SGV|sda|SDA|sdd|SDD|vor|VOR|svm|SVM|wmf|WMF|bmp|BMP|gif|GIF|jpg|JPG|jpeg|JPEG|jfif|JFIF|fif|FIF|jpe|JPE|pcd|PCD|pcx|PCX|pgm|PGM|png|PNG|ppm|PPM|psd|PSD|ras|RAS|tga|TGA|tif|TIF|tiff|TIFF|xbm|XBM|xpm|XPM|odg|ODG|otg|OTG|fodg|FODG|odc|ODC|odi|ODI|sds|SDS|wpg|WPG|svg|SVG|vdx|VDX|vsd|VSD|vsdm|VSDM|vsdx|VSDX|doc|DOC|dot|DOT|rtf|RTF|sxw|SXW|stw|STW|sdw|SDW|vor|VOR|txt|TXT|htm?|HTM?|xml|XML|wp|WP|wpd|WPD|wps|WPS|odt|ODT|ott|OTT|fodt|FODT|docm|DOCM|docx|DOCX|dotm|DOTM|dotx|DOTX|sxm|SXM|smf|SMF|mml|MML|odf|ODF|sxi|SXI|sti|STI|ppt|PPT|pps|PPS|pot|POT|sxd|SXD|sda|SDA|sdd|SDD|sdp|SDP|vor|VOR|cgm|CGM|odp|ODP|otp|OTP|fodp|FODP|ppsm|PPSM|ppsx|PPSX|pptm|PPTM|pptx|PPTX|potm|POTM|potx|POTX|odb|ODB|sxc|SXC|stc|STC|dif|DIF|dbf|DBF|xls|XLS|xlw|XLW|xlt|XLT|rtf|RTF|sdc|SDC|vor|VOR|slk|SLK|txt|TXT|htm|HTM|html|HTML|wk1|WK1|wks|WKS|123|123|xml|XML|ods|ODS|ots|OTS|fods|FODS|csv|CSV|xlsb|XLSB|xlsm|XLSM|xlsx|XLSX|xltm|XLTM|xltx|XLTX|sxg|SXG|odm|ODM|sgl|SGL|stw|STW|dot|DOT|vor|VOR|stc|STC|xlt|XLT|sti|STI|pot|POT|std|STD|stw|STW|dotm|DOTM|dotx|DOTX|potm|POTM|potx|POTX|xltm|XLTM|xltx|XLTX|htm|HTM|html|HTML|stw|STW|txt|TXT|vor|VOR|oth|OTH)'
        ;;
        lomath)
            e='!*.+(sxm|SXM|smf|SMF|mml|MML|odf|ODF)'
        ;;
        loimpress)
            e='!*.+(sxi|SXI|sti|STI|ppt|PPT|pps|PPS|pot|POT|sxd|SXD|sda|SDA|sdd|SDD|sdp|SDP|vor|VOR|cgm|CGM|odp|ODP|otp|OTP|fodp|FODP|ppsm|PPSM|ppsx|PPSX|pptm|PPTM|pptx|PPTX|potm|POTM|potx|POTX)'
        ;;
        localc)
            e='!*.+(sxc|SXC|stc|STC|dif|DIF|dbf|DBF|xls|XLS|xlw|XLW|xlt|XLT|rtf|RTF|sdc|SDC|vor|VOR|slk|SLK|txt|TXT|htm|HTM|html|HTML|wk1|WK1|wks|WKS|123|123|xml|XML|ods|ODS|ots|OTS|fods|FODS|csv|CSV|xlsb|XLSB|xlsm|XLSM|xlsx|XLSX|xltm|XLTM|xltx|XLTX)'
        ;;
        lofromtemplate)
            e='!*.+(stw|STW|dot|DOT|vor|VOR|stc|STC|xlt|XLT|sti|STI|pot|POT|std|STD|stw|STW|dotm|DOTM|dotx|DOTX|potm|POTM|potx|POTX|xltm|XLTM|xltx|XLTX)'
        ;;
        loweb)
            e='!*.+(htm|HTM|html|HTML|stw|STW|txt|TXT|vor|VOR|oth|OTH)'
        ;;
        *)
            e='!*'
        ;;
    esac;
    case "$(complete -p ${1##*/} 2> /dev/null)" in 
        *-d*)

        ;;
        *)
            s="-S/"
        ;;
    esac;
    IFS='
';
    case "$c" in 
        \$\(*\))
            eval COMPREPLY=\(${c}\)
        ;;
        \$\(*)
            COMPREPLY=($(compgen -c -P '$(' -S ')'  -- ${c#??}))
        ;;
        \`*\`)
            eval COMPREPLY=\(${c}\)
        ;;
        \`*)
            COMPREPLY=($(compgen -c -P '\`' -S '\`' -- ${c#?}))
        ;;
        \$\{*\})
            eval COMPREPLY=\(${c}\)
        ;;
        \$\{*)
            COMPREPLY=($(compgen -v -P '${' -S '}'  -- ${c#??}))
        ;;
        \$*)
            COMPREPLY=($(compgen -v -P '$'          -- ${c#?}))
        ;;
        \~*/*)
            COMPREPLY=($(compgen -f -X "$e"         -- ${c}))
        ;;
        \~*)
            COMPREPLY=($(compgen -u ${s}	 	-- ${c}))
        ;;
        *@*)
            COMPREPLY=($(compgen -A hostname -P '@' -S ':' -- ${c#*@}))
        ;;
        *[*?[]*)
            COMPREPLY=($(compgen -G "${c}"))
        ;;
        *[?*+\!@]\(*\)*)
            if test $g -eq 0; then
                COMPREPLY=($(compgen -f -X "$e" -- $c));
                test $g -eq 0 && shopt -u extglob;
                return;
            fi;
            COMPREPLY=($(compgen -G "${c}"))
        ;;
        *)
            if test "$c" = ".."; then
                COMPREPLY=($(compgen -d -X "$e" -S / ${_nosp} -- $c));
            else
                for s in $(compgen -f -X "$e" -- $c);
                do
                    if test -d $s; then
                        COMPREPLY=(${COMPREPLY[@]} $(compgen -f -X "$e" -S / -- $s));
                    else
                        if test -z "$t"; then
                            COMPREPLY=(${COMPREPLY[@]} $s);
                        else
                            case "$(file -b $s 2> /dev/null)" in 
                                $t)
                                    COMPREPLY=(${COMPREPLY[@]} $s)
                                ;;
                            esac;
                        fi;
                    fi;
                done;
            fi
        ;;
    esac;
    test $g -eq 0 && shopt -u extglob
}
_longopt () 
{ 
    local cur prev words cword split;
    _init_completion -s || return;
    case "${prev,,}" in 
        --help | --usage | --version)
            return 0
        ;;
        --*dir*)
            _filedir -d;
            return 0
        ;;
        --*file* | --*path*)
            _filedir;
            return 0
        ;;
        --+([-a-z0-9_]))
            local argtype=$( $1 --help 2>&1 | sed -ne                 "s|.*$prev\[\{0,1\}=[<[]\{0,1\}\([-A-Za-z0-9_]\{1,\}\).*|\1|p" );
            case ${argtype,,} in 
                *dir*)
                    _filedir -d;
                    return 0
                ;;
                *file* | *path*)
                    _filedir;
                    return 0
                ;;
            esac
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W "$( $1 --help 2>&1 |             sed -ne 's/.*\(--[-A-Za-z0-9]\{1,\}=\{0,1\}\).*/\1/p' | sort -u )"             -- "$cur" ));
        [[ $COMPREPLY == *= ]] && compopt -o nospace;
    else
        if [[ "$1" == @(mk|rm)dir ]]; then
            _filedir -d;
        else
            _filedir;
        fi;
    fi
}
_mac_addresses () 
{ 
    local re='\([A-Fa-f0-9]\{2\}:\)\{5\}[A-Fa-f0-9]\{2\}';
    local PATH="$PATH:/sbin:/usr/sbin";
    COMPREPLY+=($(         { LC_ALL=C ifconfig -a || ip link show; } 2>/dev/null | sed -ne         "s/.*[[:space:]]HWaddr[[:space:]]\{1,\}\($re\)[[:space:]].*/\1/p" -ne         "s/.*[[:space:]]HWaddr[[:space:]]\{1,\}\($re\)[[:space:]]*$/\1/p" -ne         "s|.*[[:space:]]\(link/\)\{0,1\}ether[[:space:]]\{1,\}\($re\)[[:space:]].*|\2|p" -ne         "s|.*[[:space:]]\(link/\)\{0,1\}ether[[:space:]]\{1,\}\($re\)[[:space:]]*$|\2|p"
        ));
    COMPREPLY+=($( { arp -an || ip neigh show; } 2>/dev/null | sed -ne         "s/.*[[:space:]]\($re\)[[:space:]].*/\1/p" -ne         "s/.*[[:space:]]\($re\)[[:space:]]*$/\1/p" ));
    COMPREPLY+=($( sed -ne         "s/^[[:space:]]*\($re\)[[:space:]].*/\1/p" /etc/ethers 2>/dev/null ));
    COMPREPLY=($( compgen -W '${COMPREPLY[@]}' -- "$cur" ));
    __ltrim_colon_completions "$cur"
}
_minimal () 
{ 
    local cur prev words cword split;
    _init_completion -s || return;
    $split && return;
    _filedir
}
_module_assistant () 
{ 
    local cur prev special i options commands;
    options='-h -v -q -n -i -o -s -f -u -k -l \
   --help --verbose --quiet --no-rebuild --non-inter --unpack-once \
   --apt-search --force --userdir --kernel-dir --kvers-list';
    commands='update unpack get fakesource build list install auto-install prepare clean purge la li a-i';
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    for ((i=0; i < ${#COMP_WORDS[@]}-1; i++ ))
    do
        if [[ ${COMP_WORDS[i]} == @(update|fakesource|unpack|get|build|list|install|auto-install|clean|purge|la|list-available|li|list-installed|a-i) ]]; then
            special=${COMP_WORDS[i]};
        fi;
    done;
    if [ -n "$special" ]; then
        case $special in 
            clean | purge)
                COMPREPLY=($( module-assistant -q compi $cur 2> /dev/null ));
                return 0
            ;;
            *)
                COMPREPLY=($( module-assistant -q comp $cur 2> /dev/null ));
                return 0
            ;;
        esac;
    fi;
    case "$prev" in 
        -@(u|k|-kernel-dir|-kernel-dirs))
            _filedir;
            return 0
        ;;
        -@(l|-kver-list))
            COMPREPLY=($( module-assistant -q compv $cur ));
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W "$options" -- $cur ));
    else
        COMPREPLY=($( compgen -W "$commands" -- $cur ));
    fi;
    return 0
}
_modules () 
{ 
    local modpath;
    modpath=/lib/modules/$1;
    COMPREPLY=($( compgen -W "$( command ls -RL $modpath 2>/dev/null |         sed -ne 's/^\(.*\)\.k\{0,1\}o\(\.[gx]z\)\{0,1\}$/\1/p' )" -- "$cur" ))
}
_mvn () 
{ 
    local i prev c=1 cmd option optionArg=0 cmdcomplete=0;
    local cur="${COMP_WORDS[COMP_CWORD]}";
    COMPREPLY=();
    while [ $c -le $COMP_CWORD ]; do
        prev=$i;
        i="${COMP_WORDS[c]}";
        c=$((++c));
        optionArg=0;
        if [[ $prev == @(${__mvnoptsWithArg}) ]]; then
            optionArg=1;
            continue;
        fi;
        if [[ $cmdcomplete == -3 ]]; then
            cmdcomplete=1;
            break;
        fi;
        if [[ "$i" == "" ]]; then
            if [[ -n $cmd ]]; then
                cmdcomplete=1;
                break;
            fi;
            continue;
        fi;
        if [[ "$i" == ":" ]]; then
            if [[ -n $cmd ]]; then
                cmdcomplete=$((cmdcomplete-1));
                cmd="${cmd}:";
            fi;
            continue;
        fi;
        case "$i" in 
            --version | --help)
                return
            ;;
            -*)
                option="$i"
            ;;
            *)
                if [[ ! -n $cmd ]]; then
                    cmdcomplete=$((cmdcomplete-1));
                    cmd="$i";
                    local next=$c;
                    if [[ $next -lt $COMP_CWORD ]]; then
                        if [[ "${COMP_WORDS[next]}" != ":" ]]; then
                            break;
                        fi;
                    fi;
                else
                    cmdcomplete=$((cmdcomplete-1));
                    cmd="$cmd$i";
                fi
            ;;
        esac;
    done;
    if [[ ! -n $cmd && -n $option && ( $optionArg == 0 ) ]]; then
        case "$option" in 
            --file)
                __mvncomp "$(__mvnlist_poms)";
                return
            ;;
            --define)
                __mvncomp "maven.test.skip=true";
                return
            ;;
            --resume-from)
                __mvncomp "$(__mvnlist_projects)";
                return
            ;;
            --projects)
                case "${cur}" in 
                    *,*)
                        __mvncomp "$(__mvnlist_projects)" "$(__mvnprefix_comma $cur)" "${cur#*,}"
                    ;;
                    *)
                        __mvncomp "$(__mvnlist_projects)"
                    ;;
                esac;
                return
            ;;
            --settings | --global-settings)
                COMPREPLY=($( compgen -f -- $cur ));
                return
            ;;
            --*)
                COMPREPLY=()
            ;;
        esac;
    fi;
    if [ $cmdcomplete -lt 0 ]; then
        case "${cmd}" in 
            *:)
                local plugin="${cmd%%:}:";
                __mvncomp "$(__mvnlist_goals $plugin)" "$(__mvnprefix_colon $cmd)" ""
            ;;
            *:*)
                local plugin="${cmd%%:*}:";
                __mvncomp "$(__mvnlist_goals $plugin)" "$(__mvnprefix_colon $cmd)" "${cmd#*:}"
            ;;
            *)
                __mvncomp "${__mvnphases} ${__mvnall_plugin_and_goals}"
            ;;
        esac;
        return;
    fi;
    if [ -z "$cmd" ]; then
        case "${cur}" in 
            -D*=*)
                COMPREPLY=()
            ;;
            -*)
                __mvncomp "${__mvnopts} ${__mvnparams}"
            ;;
            --*)
                __mvncomp "${__mvnopts}"
            ;;
            *)
                __mvncomp "${__mvnphases} ${__mvnall_plugin_and_goals}"
            ;;
        esac;
        return;
    fi;
    case "$cmd" in 
        *:help)
            local plugin="${cmd%%:*}:";
            __mvnplugin_help $plugin
        ;;
        help:describe)
            __mvnhelp_describe
        ;;
        deploy:deploy)
            __mvndeploy_deploy
        ;;
        deploy:deploy-file)
            __mvndeploy_deploy_file
        ;;
        archetype:generate)
            __mvnarchetype_generate
        ;;
        dependency:copy-dependencies)
            __mvndependency_x_dependencies
        ;;
        dependency:unpack-dependencies)
            __mvndependency_x_dependencies
        ;;
        dependency:resolve)
            __mvndependency_resolve
        ;;
        dependency:resolve-plugins)
            __mvndependency_resolve
        ;;
        dependency:source)
            __mvndependency_resolve
        ;;
        dependency:go-offline)
            __mvndependency_resolve
        ;;
        dependency:purge-local-repository)
            __mvndependency_purge_local_repository
        ;;
        dependency:analyze)
            __mvndependency_analyze
        ;;
        dependency:analyze-dep-mgt)
            __mvndependency_analyze_dep_mgt
        ;;
        install:install-file)
            __mvninstall_install_file
        ;;
        release:prepare)
            __mvnrelease_prepare
        ;;
        scm:checkin)
            __mvnscm_checkin
        ;;
        *)

        ;;
    esac
}
_ncpus () 
{ 
    local var=NPROCESSORS_ONLN;
    [[ $OSTYPE == *linux* ]] && var=_$var;
    local n=$( getconf $var 2>/dev/null );
    printf %s ${n:-1}
}
_npm_completion () 
{ 
    local si="$IFS";
    IFS='
' COMPREPLY=($(COMP_CWORD="$COMP_CWORD"                            COMP_LINE="$COMP_LINE"                            COMP_POINT="$COMP_POINT"                            npm completion -- "${COMP_WORDS[@]}"                            2>/dev/null)) || return $?;
    IFS="$si"
}
_openvpn () 
{ 
    local cur;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($( compgen -W '$( /etc/init.d/openvpn 2>&1 \
              | cut -d"{" -f2 | tr -d "}" | tr "|" " " )' -- $cur ));
    else
        COMPREPLY=($( compgen -W '$( command ls /etc/openvpn/*.conf 2>/dev/null \
              | sed -e 's%/etc/openvpn/%%' -e 's/\.conf//' )' -- $cur ));
    fi
}
_pacat () 
{ 
    local cur prev comps;
    local flags='-h --help --version -r --record -p --playback -v --verbose -s
                --server= -d --device= -n --client-name= --stream-name= --volume=
                --rate= --format= --channels= --channel-map= --fix-format --fix-rate
                --fix-channels --no-remix --no-remap --latency= --process-time=
                --latency-msec= --process-time-msec= --property= --raw --passthrough
                --file-format= --list-file-formats';
    _init_completion -n = || return;
    case $cur in 
        --server=*)
            cur=${cur#*=};
            _known_hosts_real "$cur"
        ;;
        --device=*)
            cur=${cur#*=};
            comps=$(__sinks);
            comps+=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --rate=*)
            cur=${cur#*=};
            COMPREPLY=($(compgen -W '32000 44100 48000 9600 192000' -- "$cur"))
        ;;
        --file-format=*)
            cur=${cur#*=};
            comps=$(_pacat_file_formats);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --*=*)

        ;;
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"));
            [[ $COMPREPLY == *= ]] && compopt -o nospace
        ;;
        *)
            _filedir
        ;;
    esac;
    case $prev in 
        -s)
            _known_hosts_real "$cur"
        ;;
        -d)
            comps=$(__sinks);
            comps+=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
    esac
}
_pacat_file_formats () 
{ 
    while IFS='	' read name _; do
        printf "%s\n" "$name";
    done < <(pacat --list-file-formats 2> /dev/null)
}
_pacmd () 
{ 
    local cur prev words cword preprev command;
    local comps;
    local flags='-h --help --version';
    local commands=(exit help list-modules list-sinks list-sources list-clients list-samples list-sink-inputs list-source-outputs stat info load-module unload-module describe-module set-sink-volume set-source-volume set-sink-input-volume set-source-output-volume set-sink-mute set-source-mut set-sink-input-mute set-source-output-mute update-sink-proplist update-source-proplist update-sink-input-proplist update-source-output-proplist set-default-sink set-default-source kill-client kill-sink-input kill-source-output play-sample remove-sample load-sample load-sample-lazy load-sample-dir-lazy play-file dump move-sink-input move-source-output suspend-sink suspend-source suspend set-card-profile set-sink-port set-source-port set-port-latency-offset set-log-target set-log-level set-log-meta set-log-time set-log-backtrace);
    _init_completion -n = || return;
    preprev=${words[$cword-2]};
    for word in "${COMP_WORDS[@]}";
    do
        if in_array "$word" "${commands[@]}"; then
            command=$word;
            break;
        fi;
    done;
    case $preprev in 
        play-sample | play-file)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        load-sample*)
            _filedir
        ;;
        move-sink-input)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        move-source-output)
            comps=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-card-profile)
            comps=$(__profiles);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-*port*)
            comps=$(__ports);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-*-mute)
            COMPREPLY=($(compgen -W 'true false' -- "$cur"))
        ;;
        set-sink-formats)

        ;;
    esac;
    case $prev in 
        list-*)

        ;;
        describe-module | load-module)
            comps=$(__all_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        unload-module)
            comps=$(__loaded_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        load-sample-dir-lazy)
            _filedir -d
        ;;
        play-file)
            _filedir
        ;;
        *sink-input*)
            comps=$(__sink_inputs);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *source-output*)
            comps=$(__source_outputs);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *sink*)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *source*)
            comps=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-card*)
            comps=$(__cards);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-port-*)
            comps=$(__cards);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-log-target)
            COMPREPLY=($(compgen -W 'auto syslog stderr file: newfile:' -- "$cur"))
        ;;
        set-log-level)
            COMPREPLY=($(compgen -W '{0..4}' -- "$cur"))
        ;;
        set-log-meta | set-log-time | suspend)
            COMPREPLY=($(compgen -W 'true false' -- "$cur"))
        ;;
    esac;
    case $cur in 
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"))
        ;;
        suspend)
            COMPREPLY=($(compgen -W 'suspend suspend-sink suspend-source' -- "$cur"))
        ;;
        load-sample)
            COMPREPLY=($(compgen -W 'load-sample load-sample-lazy load-sample-dir-lazy' -- "$cur"))
        ;;
        *)
            [[ -z $command ]] && COMPREPLY=($(compgen -W '${commands[*]}' -- "$cur"))
        ;;
    esac
}
_pactl () 
{ 
    local cur prev words cword preprev command;
    local comps;
    local flags='-h --help --version -s --server= --client-name=';
    local list_types='short sinks sources sink-inputs source outputs cards
                    modules samples clients';
    local commands=(stat info list exit upload-sample play-sample remove-sample load-module unload-module move-sink-input move-source-output suspend-sink suspend-source set-card-profile set-sink-port set-source-port set-sink-volume set-source-volume set-sink-input-volume set-source-output-volume set-sink-mute set-source-mute set-sink-input-mute set-source-output-mute set-sink-formats set-port-latency-offset subscribe help);
    _init_completion -n = || return;
    preprev=${words[$cword-2]};
    for word in "${COMP_WORDS[@]}";
    do
        if in_array "$word" "${commands[@]}"; then
            command=$word;
            break;
        fi;
    done;
    case $preprev in 
        list)
            COMPREPLY=($(compgen -W 'short' -- "$cur"))
        ;;
        play-sample)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        move-sink-input)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        move-source-output)
            comps=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-card-profile)
            comps=$(__profiles);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-*-port)
            comps=$(__ports);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-*-mute)
            COMPREPLY=($(compgen -W 'true false toggle' -- "$cur"))
        ;;
        set-sink-formats)

        ;;
        set-port-*)
            comps=$(__ports);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --server)
            compopt +o nospace;
            _known_hosts_real "$cur"
        ;;
    esac;
    [[ -n $COMPREPLY ]] && return 0;
    case $prev in 
        list)
            COMPREPLY=($(compgen -W '${list_types[*]}' -- "$cur"))
        ;;
        stat)
            COMPREPLY=($(compgen -W 'short' -- "$cur"))
        ;;
        upload-sample)
            _filedir
        ;;
        play-sample)

        ;;
        remove-sample)

        ;;
        load-module)
            comps=$(__all_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        unload-module)
            comps=$(__loaded_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-card*)
            comps=$(__cards);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *sink-input*)
            comps=$(__sink_inputs);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *source-output*)
            comps=$(__source_outputs);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-sink-formats)
            comps=$(__sinks_idx);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *sink*)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *source*)
            comps=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-port*)
            comps=$(__cards);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        -s)
            _known_hosts_real "$cur"
        ;;
    esac;
    [[ -n $COMPREPLY ]] && return 0;
    case $cur in 
        --server=*)
            cur=${cur#*=};
            _known_hosts_real "$cur"
        ;;
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"));
            [[ $COMPREPLY == *= ]] && compopt -o nospace
        ;;
        *)
            [[ -z $command ]] && COMPREPLY=($(compgen -W '${commands[*]}' -- "$cur"))
        ;;
    esac
}
_padsp () 
{ 
    local cur prev;
    local flags='-h -s -n -m -M -S -D -d';
    _get_comp_words_by_ref cur prev;
    case $cur in 
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"))
        ;;
    esac;
    case $prev in 
        -s)
            _known_hosts_real "$cur"
        ;;
    esac
}
_parse_help () 
{ 
    eval local cmd=$( quote "$1" );
    local line;
    { 
        case $cmd in 
            -)
                cat
            ;;
            *)
                LC_ALL=C "$( dequote "$cmd" )" ${2:---help} 2>&1
            ;;
        esac
    } | while read -r line; do
        [[ $line == *([ '	'])-* ]] || continue;
        while [[ $line =~ ((^|[^-])-[A-Za-z0-9?][[:space:]]+)\[?[A-Z0-9]+\]? ]]; do
            line=${line/"${BASH_REMATCH[0]}"/"${BASH_REMATCH[1]}"};
        done;
        __parse_options "${line// or /, }";
    done
}
_parse_usage () 
{ 
    eval local cmd=$( quote "$1" );
    local line match option i char;
    { 
        case $cmd in 
            -)
                cat
            ;;
            *)
                LC_ALL=C "$( dequote "$cmd" )" ${2:---usage} 2>&1
            ;;
        esac
    } | while read -r line; do
        while [[ $line =~ \[[[:space:]]*(-[^]]+)[[:space:]]*\] ]]; do
            match=${BASH_REMATCH[0]};
            option=${BASH_REMATCH[1]};
            case $option in 
                -?(\[)+([a-zA-Z0-9?]))
                    for ((i=1; i < ${#option}; i++ ))
                    do
                        char=${option:i:1};
                        [[ $char != '[' ]] && printf '%s\n' -$char;
                    done
                ;;
                *)
                    __parse_options "$option"
                ;;
            esac;
            line=${line#*"$match"};
        done;
    done
}
_pasuspender () 
{ 
    local cur prev;
    local flags='-h --help --version -s --server=';
    _init_completion -n = || return;
    case $cur in 
        --server=*)
            cur=${cur#*=};
            _known_hosts_real "$cur"
        ;;
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"));
            [[ $COMPREPLY == *= ]] && compopt -o nospace
        ;;
    esac;
    case $prev in 
        -s)
            _known_hosts_real "$cur"
        ;;
    esac
}
_pci_ids () 
{ 
    COMPREPLY+=($( compgen -W         "$( PATH="$PATH:/sbin" lspci -n | awk '{print $3}')" -- "$cur" ))
}
_pgids () 
{ 
    COMPREPLY=($( compgen -W '$( command ps axo pgid= )' -- "$cur" ))
}
_pids () 
{ 
    COMPREPLY=($( compgen -W '$( command ps axo pid= )' -- "$cur" ))
}
_pnames () 
{ 
    COMPREPLY=($( compgen -X '<defunct>' -W '$( command ps axo command= | \
        sed -e "s/ .*//" -e "s:.*/::" -e "s/:$//" -e "s/^[[(-]//" \
            -e "s/[])]$//" | sort -u )' -- "$cur" ))
}
_poff () 
{ 
    local prev cur conns;
    [ -r /etc/ppp/peers/ ] || return 0;
    COMPREPLY=();
    prev=${COMP_WORDS[COMP_CWORD-1]};
    cur=${COMP_WORDS[COMP_CWORD]};
    conns=$(\ls --color=none /etc/ppp/peers | egrep -v '(\.bak|~)$');
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W '-r -d -c -a -h -v' -- $cur));
        return 0;
    fi;
    if [ $COMP_CWORD -eq 1 ] && [[ "$cur" != -* ]] || [[ "$prev" == -* ]]; then
        COMPREPLY=($(compgen -o filenames -W "$conns" $cur));
    fi;
    return 0
}
_pon () 
{ 
    local cur conns;
    [ -r /etc/ppp/peers/ ] || return 0;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    conns=$(\ls --color=none /etc/ppp/peers | egrep -v '(\.bak|~)$');
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($(compgen -o filenames -W "$conns" $cur));
    fi;
    return 0
}
_pulseaudio () 
{ 
    local cur prev words cword;
    local flags='-h --help --version --dump-conf --dump-resample-methods --cleanup-shm
                --start -k --kill --check --system= -D --daemonize= --fail= --high-priority=
                --realtime= --disallow-module-loading= --disallow-exit= --exit-idle-time=
                --scache-idle-time= --log-level= -v --log-target= --log-meta= --log-time=
                --log-backtrace= -p --dl-search-path= --resample-method= --use-pit-file=
                --no-cpu-limit= --disable-shm= -L --load= -F --file= -C -n';
    _init_completion -n = || return;
    case $cur in 
        --system=* | --daemonize=* | --fail=* | --high-priority=* | --realtime=* | --disallow-*=* | --log-meta=* | --log-time=* | --use-pid-file=* | --no-cpu-limit=* | --disable-shm=*)
            cur=${cur#*=};
            COMPREPLY=($(compgen -W 'true false' -- "$cur"))
        ;;
        --log-target=*)
            cur=${cur#*=};
            COMPREPLY=($(compgen -W 'auto syslog stderr file: newfile:' -- "$cur"))
        ;;
        --log-level=*)
            cur=${cur#*=};
            COMPREPLY=($(compgen -W '{0..4}' -- "$cur"))
        ;;
        --dl-search-path=*)
            cur=${cur#*=};
            _filedir -d
        ;;
        --file=*)
            cur=${cur#*=};
            _filedir
        ;;
        --resample-method=*)
            cur=${cur#*=};
            comps=$(__resample_methods);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --load=*)
            cur=${cur#*=};
            comps=$(__all_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --*=*)

        ;;
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"));
            [[ $COMPREPLY == *= ]] && compopt -o nospace
        ;;
    esac;
    case $prev in 
        -D)
            COMPREPLY=($(compgen -W 'true false' -- "$cur"))
        ;;
        -p)
            _filedir -d
        ;;
        -F)
            _filedir
        ;;
        -L)
            cur=${cur#*=};
            comps=$(__all_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
    esac
}
_pygmentize () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        -f)
            FORMATTERS=`pygmentize -L formatters | grep '* ' | cut -c3- | sed -e 's/,//g' -e 's/:$//'`;
            COMPREPLY=($( compgen -W '$FORMATTERS' -- "$cur" ));
            return 0
        ;;
        -l)
            LEXERS=`pygmentize -L lexers | grep '* ' | cut -c3- | sed -e 's/,//g' -e 's/:$//'`;
            COMPREPLY=($( compgen -W '$LEXERS' -- "$cur" ));
            return 0
        ;;
        -S)
            STYLES=`pygmentize -L styles | grep '* ' | cut -c3- | sed s/:$//`;
            COMPREPLY=($( compgen -W '$STYLES' -- "$cur" ));
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-f -l -S -L -g -O -P -F \
                                   -N -H -h -V -o' -- "$cur" ));
        return 0;
    fi
}
_quote_readline_by_ref () 
{ 
    if [ -z "$1" ]; then
        printf -v $2 %s "$1";
    else
        if [[ $1 == \'* ]]; then
            printf -v $2 %s "${1:1}";
        else
            if [[ $1 == ~* ]]; then
                printf -v $2 ~%q "${1:1}";
            else
                printf -v $2 %q "$1";
            fi;
        fi;
    fi;
    [[ ${!2} == *\\* ]] && printf -v $2 %s "${1//\\\\/\\}";
    [[ ${!2} == \$* ]] && eval $2=${!2}
}
_realcommand () 
{ 
    type -P "$1" > /dev/null && { 
        if type -p realpath > /dev/null; then
            realpath "$(type -P "$1")";
        else
            if type -p greadlink > /dev/null; then
                greadlink -f "$(type -P "$1")";
            else
                if type -p readlink > /dev/null; then
                    readlink -f "$(type -P "$1")";
                else
                    type -P "$1";
                fi;
            fi;
        fi
    }
}
_rl_enabled () 
{ 
    [[ "$( bind -v )" = *$1+([[:space:]])on* ]]
}
_root_command () 
{ 
    local PATH=$PATH:/sbin:/usr/sbin:/usr/local/sbin;
    local root_command=$1;
    _command
}
_samtools () 
{ 
    local cur prev opts;
    COMPREPLY=();
    cur="${COMP_WORDS[COMP_CWORD]}";
    prev="${COMP_WORDS[COMP_CWORD-1]}";
    opts="view sort mpileup depth 
        faidx tview index idxstats 
        fixmate flagstat calmd merge 
        rmdup reheader cat targetcut 
        phase pad2unpad";
    case $prev in 
        samtools)
            COMPREPLY=($(compgen -W "${opts}" -- ${cur}))
        ;;
    esac;
    return 0
}
_service () 
{ 
    local cur prev words cword;
    _init_completion || return;
    [[ $cword -gt 2 ]] && return 0;
    if [[ $cword -eq 1 && $prev == ?(*/)service ]]; then
        _services;
        [[ -e /etc/mandrake-release ]] && _xinetd_services;
    else
        local sysvdirs;
        _sysvdirs;
        COMPREPLY=($( compgen -W '`sed -e "y/|/ /" \
            -ne "s/^.*\(U\|msg_u\)sage.*{\(.*\)}.*$/\2/p" \
            ${sysvdirs[0]}/${prev##*/} 2>/dev/null` start stop' -- "$cur" ));
    fi
}
_services () 
{ 
    local sysvdirs;
    _sysvdirs;
    local restore_nullglob=$(shopt -p nullglob);
    shopt -s nullglob;
    COMPREPLY=($( printf '%s\n' ${sysvdirs[0]}/!($_backup_glob|functions) ));
    $restore_nullglob;
    COMPREPLY+=($( systemctl list-units --full --all 2>/dev/null |         awk '$1 ~ /\.service$/ { sub("\\.service$", "", $1); print $1 }' ));
    COMPREPLY=($( compgen -W '${COMPREPLY[@]#${sysvdirs[0]}/}' -- "$cur" ))
}
_shells () 
{ 
    local shell rest;
    while read -r shell rest; do
        [[ $shell == /* && $shell == "$cur"* ]] && COMPREPLY+=($shell);
    done 2> /dev/null < /etc/shells
}
_signals () 
{ 
    local -a sigs=($( compgen -P "$1" -A signal "SIG${cur#$1}" ));
    COMPREPLY+=("${sigs[@]/#${1}SIG/${1}}")
}
_split_longopt () 
{ 
    if [[ "$cur" == --?*=* ]]; then
        prev="${cur%%?(\\)=*}";
        cur="${cur#*=}";
        return 0;
    fi;
    return 1
}
_subdirectories () 
{ 
    COMPREPLY=($( cd $1 && compgen -d -- "$cur" ))
}
_svn () 
{ 
    local cur cmds cmdOpts pOpts mOpts rOpts qOpts nOpts optsParam opt;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='add blame annotate praise cat changelist cl checkout co cleanup';
    cmds="$cmds commit ci copy cp delete remove rm diff export help import";
    cmds="$cmds info list ls lock log merge mergeinfo mkdir move mv rename";
    cmds="$cmds patch propdel pdel propedit pedit propget pget proplist";
    cmds="$cmds plist propset pset relocate resolve resolved revert status";
    cmds="$cmds  switch unlock update upgrade";
    local helpOpts='--help -h';
    local specOpts="--version $helpOpts";
    optsParam="-r|--revision|--username|--password|--targets";
    optsParam="$optsParam|-x|--extensions|-m|--message|-F|--file";
    optsParam="$optsParam|--encoding|--diff-cmd|--diff3-cmd|--editor-cmd";
    optsParam="$optsParam|--old|--new|--config-dir|--config-option";
    optsParam="$optsParam|--native-eol|-l|--limit|-c|--change";
    optsParam="$optsParam|--depth|--set-depth|--with-revprop";
    optsParam="$optsParam|--cl|--changelist|--accept|--show-revs";
    local svnProps revProps allProps psCmds propCmds;
    svnProps="svn:keywords svn:executable svn:needs-lock svn:externals
	          svn:ignore svn:eol-style svn:mime-type $SVN_BASH_FILE_PROPS";
    revProps="svn:author svn:log svn:date $SVN_BASH_REV_PROPS";
    allProps=($svnProps $revProps);
    psCmds='propset|pset|ps';
    propCmds="$psCmds|propget|pget|pg|propedit|pedit|pe|propdel|pdel|pd";
    local urlSchemas='file:/// http:// https:// svn:// svn+ssh://';
    local cmd= isPropCmd= isPsCmd= isHelpCmd= nExpectArgs= isCur= i=0;
    local prev= help= prop= val= isRevProp= last='none' nargs=0 stat=;
    local options= hasRevPropOpt= hasRevisionOpt= hasRelocateOpt=;
    local acceptOpt= URL= hasReintegrateOpt=;
    for opt in "${COMP_WORDS[@]}";
    do
        [[ -n $isCur ]] && stat=$last;
        isCur=;
        [[ $i -eq $COMP_CWORD ]] && isCur=1;
        let i++;
        [ $last = 'none' ] && { 
            last='first';
            continue
        };
        if [[ $prev == @($optsParam) ]]; then
            [[ $prev = '--accept' ]] && acceptOpt=$opt;
            prev='';
            last='skip';
            continue;
        fi;
        if [[ $prev == @(<|>|>>|[12]>|[12]>>) ]]; then
            prev='';
            last='skip';
            continue;
        fi;
        prev=$opt;
        if [[ ! -n $cmd && -n $opt && ( $opt != -* || $opt == @(${specOpts// /|}) ) ]]; then
            cmd=$opt;
            [[ $cmd == @($propCmds) ]] && isPropCmd=1;
            [[ $cmd == @($psCmds) ]] && isPsCmd=1;
            [[ $cmd == @(${helpOpts// /|}) ]] && cmd='help';
            [[ $cmd = 'help' ]] && isHelpCmd=1;
            if [[ -n $isHelpCmd && -n $cmd && $cmd != 'help' && ! -n $help ]]; then
                help=$cmd;
                cmd='help';
            fi;
            last='cmd';
            continue;
        fi;
        if [[ -n $isHelpCmd && ! -n $help && -n $opt && $opt != -* ]]; then
            help=$opt;
            last='help';
            continue;
        fi;
        if [[ -n $isPropCmd && ! -n $prop && -n $opt && $opt != -* ]]; then
            prop=$opt;
            [[ $prop == @(${revProps// /|}) ]] && isRevProp=1;
            last='prop';
            continue;
        fi;
        if [[ -n $isPsCmd && -n $prop && ! -n $val && $opt != -* ]]; then
            val=$opt;
            last='val';
            continue;
        fi;
        if [[ $last != 'onlyarg' ]]; then
            case $opt in 
                -r | --revision | --revision=*)
                    hasRevisionOpt=1
                ;;
                --revprop)
                    hasRevPropOpt=1;
                    allProps=($revProps);
                    nExpectArgs=1
                ;;
                -h | --help)
                    isHelpCmd=1
                ;;
                -F | --file)
                    val='-F'
                ;;
                --relocate)
                    hasRelocateOpt=1
                ;;
                --reintegrate)
                    hasReintegrateOpt=1
                ;;
            esac;
            if [[ $opt = '--' && ! -n $isCur ]]; then
                last='onlyarg';
                continue;
            fi;
            if [[ $opt == -* ]]; then
                [[ ! -n $isCur ]] && options="$options $opt ";
                last='opt';
                continue;
            fi;
        else
            let nargs++;
            continue;
        fi;
        if [[ $cmd = 'merge' && ! -n $URL ]]; then
            URL=$opt;
        fi;
        last='arg';
        let nargs++;
    done;
    [[ -n $stat ]] || stat=$last;
    if [[ ! -n $cmd || $stat = 'cmd' ]]; then
        COMPREPLY=($( compgen -W "$cmds $specOpts" -- $cur ));
        return 0;
    fi;
    if [[ $stat = 'help' || ( -n $isHelpCmd && ! -n $help ) ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    if [[ $cmd == @(co|checkout|ls|list) && $stat = 'arg' && $SVN_BASH_COMPL_EXT == *urls* ]]; then
        if [[ $cur == file:* ]]; then
            local where=${cur/file:/};
            COMPREPLY=($(compgen -d -S '/' -X '*/.*' -- $where ));
            return;
        else
            if [[ $cur == *:* ]]; then
                local urls= file=;
                for file in ~/.subversion/auth/svn.simple/*;
                do
                    if [ -r $file ]; then
                        local url=$(_svn_read_hashfile svn:realmstring < $file);
                        url=${url/*</};
                        url=${url/>*/};
                        urls="$urls $url";
                    fi;
                done;
                local prefix=${cur%:*} suffix=${cur#*:} c= choices=;
                for c in $urls;
                do
                    [[ $c == $prefix:* ]] && choices="$choices ${c#*:}";
                done;
                COMPREPLY=($(compgen -W "$choices" -- $suffix ));
                return;
            else
                COMPREPLY=($(compgen -W "$urlSchemas" -- $cur));
                return;
            fi;
        fi;
    fi;
    if [[ $cmd = 'merge' || $cmd = 'mergeinfo' ]]; then
        local here=$(_svn_info URL);
        if [[ ! -n $URL && $stat = 'arg' ]]; then
            if [[ "$here" == */branches/* ]]; then
                COMPREPLY=($(compgen -W ${here/\/branches\/*/\/trunk} -- $cur ));
                return 0;
            else
                if [[ "$here" == */trunk* ]]; then
                    COMPREPLY=($(compgen -W ${here/\/trunk*/\/branches\/} -- $cur ));
                    return 0;
                else
                    COMPREPLY=($(compgen -W $(_svn_info Root) -- $cur ));
                    return 0;
                fi;
            fi;
        else
            if [[ $URL == */branches/* && $here == */trunk* && ! -n $hasReintegrateOpt && $cur = '' && $stat = 'arg' ]]; then
                COMPREPLY=($(compgen -W '--reintegrate' -- $cur ));
                return 0;
            fi;
        fi;
    fi;
    if [[ $stat = 'skip' ]]; then
        local previous=${COMP_WORDS[COMP_CWORD-1]};
        local values= dirs= beep= exes=;
        [[ $previous = '--config-dir' ]] && dirs=1;
        [[ $previous = --*-cmd ]] && exes=1;
        [[ $previous = '--native-eol' ]] && values='LF CR CRLF';
        [[ $previous = '--limit' ]] && values='0 1 2 3 4 5 6 7 8 9';
        [[ $previous = '--revision' || $previous = '-r' ]] && values='HEAD BASE PREV COMMITTED 0 {';
        [[ $previous = '--encoding' ]] && values="latin1 utf8 $SVN_BASH_ENCODINGS";
        [[ $previous = '--extensions' || $previous = '-x' ]] && values="--unified --ignore-space-change 		   --ignore-all-space --ignore-eol-style --show-c-functions";
        [[ $previous = '--depth' ]] && values='empty files immediates infinity';
        [[ $previous = '--set-depth' ]] && values='empty exclude files immediates infinity';
        [[ $previous = '--accept' ]] && { 
            if [[ $cmd = 'resolve' ]]; then
                values='base working mine-full theirs-full';
            else
                values="postpone base mine-full theirs-full edit launch 			mine-conflict theirs-conflict";
            fi
        };
        [[ $previous = '--show-revs' ]] && values='merged eligible';
        if [[ $previous = '--username' ]]; then
            values="$SVN_BASH_USERNAME";
            if [[ $SVN_BASH_COMPL_EXT == *username* ]]; then
                local file=;
                for file in ~/.subversion/auth/svn.simple/*;
                do
                    if [ -r $file ]; then
                        values="$values $(_svn_read_hashfile username < $file)";
                    fi;
                done;
            fi;
            [[ ! -n "$values" ]] && beep=1;
        fi;
        [[ $previous = '--password' ]] && beep=1;
        [[ -n $values ]] && COMPREPLY=($( compgen -W "$values" -- $cur ));
        [[ -n $dirs ]] && COMPREPLY=($( compgen -o dirnames -- $cur ));
        [[ -n $exes ]] && COMPREPLY=($( compgen -c -- $cur ));
        [[ -n $beep ]] && { 
            echo -en "\a";
            COMPREPLY=('')
        };
        return 0;
    fi;
    if [[ -n $isPropCmd && ( ! -n $prop || $stat = 'prop' ) && $cur != -* ]]; then
        local choices=;
        if [[ $cur == *:* ]]; then
            local prefix=${cur%:*} suffix=${cur#*:} c=;
            for c in ${allProps[@]};
            do
                [[ $c == $prefix:* ]] && choices="$choices ${c#*:}";
            done;
            cur=$suffix;
        else
            COMPREPLY=($( compgen -W "${allProps[*]}" -- $cur ));
            [ ${#COMPREPLY[@]} -eq 1 ] && return 0;
            local seen= n=0 last= c=;
            for c in ${allProps[@]%:*};
            do
                if [[ $c == $cur* && ( ! -n $seen || $c != @($seen) ) ]]; then
                    let n++;
                    last=$c;
                    choices="$choices $c:";
                    if [[ -n $seen ]]; then
                        seen="$seen|$c*";
                    else
                        seen="$c*";
                    fi;
                fi;
            done;
            [[ $n -eq 1 ]] && choices="$last:1 $last:2";
        fi;
        COMPREPLY=($( compgen -W "$choices" -- $cur ));
        return 0;
    fi;
    if [[ -n $isRevProp && ! -n $hasRevPropOpt ]]; then
        COMPREPLY=($( compgen -W '--revprop' -- $cur ));
        return 0;
    fi;
    if [[ -n $isRevProp && -n $hasRevPropOpt && ! -n $hasRevisionOpt ]]; then
        COMPREPLY=($( compgen -W '--revision' -- $cur ));
        return 0;
    fi;
    if [[ -n $isPsCmd && -n $prop && ( ! -n $val || $stat = 'val' ) ]]; then
        local values="\' --file";
        case $prop in 
            svn:keywords)
                values="Id Rev URL Date Author Header \' $SVN_BASH_KEYWORDS"
            ;;
            svn:executable | svn:needs-lock)
                values='\\*'
            ;;
            svn:eol-style)
                values='native LF CR CRLF'
            ;;
            svn:mime-type)
                values="text/ text/plain text/html text/xml text/rtf
                       image/ image/png image/gif image/jpeg image/tiff
                       audio/ audio/midi audio/mpeg
                       video/ video/mpeg video/mp4
                       application/ application/octet-stream
                       $SVN_BASH_MIME_TYPE"
            ;;
        esac;
        COMPREPLY=($( compgen -W "$values" -- $cur ));
        [[ -n ${COMPREPLY} ]] && return 0;
    fi;
    case $cmd in 
        merge)
            nExpectArgs=3
        ;;
        mergeinfo)
            nExpectArgs=1
        ;;
        copy | cp | move | mv | rename | ren | export | import)
            nExpectArgs=2
        ;;
        switch | sw)
            [[ ! -n $hasRelocateOpt ]] && nExpectArgs=2
        ;;
        help | h)
            nExpectArgs=0
        ;;
        --version)
            nExpectArgs=0
        ;;
    esac;
    if [[ -n $nExpectArgs && $nargs -gt $nExpectArgs ]]; then
        echo -en "\a";
        COMPREPLY=('');
        return 0;
    fi;
    if [[ $cur != -* || $stat = 'onlyarg' ]]; then
        if [[ $SVN_BASH_COMPL_EXT == *svnstatus* ]]; then
            local status='svn status --non-interactive';
            [[ $SVN_BASH_COMPL_EXT == *recurse* ]] || status="$status --non-recursive";
            [[ $SVN_BASH_COMPL_EXT == *externals* ]] || status="$status --ignore-externals";
            local cs= files=;
            [[ -n $cur ]] && cs=$cur*;
            case $cmd in 
                st*)
                    files=$cur*
                ;;
                ci | commit | revert | di*)
                    files=$($status $cs| _svn_grcut '@([MADR!]*| M*|_M*)')
                ;;
                add)
                    files=$($status $cs| _svn_grcut '\?*')
                ;;
                unlock)
                    files=$($status $cs| _svn_grcut '@(??L*|?????[KOTB]*)')
                ;;
                resolve*)
                    files=$($status $cs| _svn_grcut '@(?C*|C*)')
                ;;
                praise | blame | ann*)
                    files=$( _svn_lls all $cur* )
                ;;
                p*)
                    if [[ $cmd == @($propCmds) && $prop == @(svn:ignore|svn:externals) ]]; then
                        files=$( _svn_lls dir . $cur* );
                    else
                        files="$( _svn_lls all $cur* )
                                   $($status $cs | _svn_grcut 'A*' )";
                    fi
                ;;
                info)
                    files="$( _svn_lls all $cur* )
                               $($status $cs | _svn_grcut 'A*' )"
                ;;
                remove | rm | del* | move | mv | rename)
                    files=$( _svn_lls all $cur* )
                ;;
                mkdir)
                    files=$( _svn_lls dir $cur* )
                ;;
                log | lock | up* | cl* | switch)
                    files=$( _svn_lls all $cur* )
                ;;
                merge)
                    files=$( _svn_lls all $cur* )
                ;;
                ls | list)
                    files=$( _svn_lls all $cur* )
                ;;
                *)
                    local fallback=1
                ;;
            esac;
            if [[ $SVN_BASH_COMPL_EXT != *recurse* ]]; then
                files="$files $( _svn_lls dir $cur* )";
            fi;
            if [[ -n $files ]]; then
                COMPREPLY=($( compgen -W "$files" -- $cur ));
                [[ -n "${COMPREPLY[*]}" ]] || COMPREPLY=('');
            else
                if [[ ! -n $fallback ]]; then
                    echo -en "\a";
                    COMPREPLY=('');
                fi;
            fi;
        fi;
        return 0;
    fi;
    pOpts="--username --password --no-auth-cache --non-interactive 	       --trust-server-cert --force-interactive";
    mOpts="-m --message -F --file --encoding --force-log --with-revprop";
    rOpts="-r --revision";
    qOpts="-q --quiet";
    nOpts="-N --non-recursive --depth";
    gOpts="-g --use-merge-history";
    cOpts="--cl --changelist";
    cmdOpts=;
    case $cmd in 
        --version)
            cmdOpts="$qOpts"
        ;;
        add)
            cmdOpts="--auto-props --no-auto-props --force --targets 		         --no-ignore --parents $nOpts $qOpts $pOpts"
        ;;
        blame | annotate | ann | praise)
            cmdOpts="$rOpts $pOpts -v --verbose --incremental --xml 		         -x --extensions --force $gOpts"
        ;;
        cat)
            cmdOpts="$rOpts $pOpts"
        ;;
        changelist | cl)
            cmdOpts="--targets $pOpts $qOpts $cOpts                          -R --recursive --depth --remove"
        ;;
        checkout | co)
            cmdOpts="$rOpts $qOpts $nOpts $pOpts --ignore-externals                          --force"
        ;;
        cleanup)
            cmdOpts="--diff3-cmd $pOpts"
        ;;
        commit | ci)
            cmdOpts="$mOpts $qOpts $nOpts --targets --editor-cmd $pOpts 		         --no-unlock $cOpts --keep-changelists 		         --include-externals"
        ;;
        copy | cp)
            cmdOpts="$mOpts $rOpts $qOpts --editor-cmd $pOpts --parents 		         --ignore-externals"
        ;;
        delete | del | remove | rm)
            cmdOpts="--force $mOpts $qOpts --targets --editor-cmd $pOpts                          --keep-local"
        ;;
        diff | di)
            cmdOpts="$rOpts -x --extensions --diff-cmd --no-diff-deleted 		         $nOpts $pOpts --force --old --new --notice-ancestry 		         -c --change --summarize $cOpts --xml --git 		         --internal-diff --show-copies-as-adds 		         --ignore-properties --properties-only --no-diff-added 		         --patch-compatible"
        ;;
        export)
            cmdOpts="$rOpts $qOpts $pOpts $nOpts --force --native-eol                          --ignore-externals --ignore-keywords"
        ;;
        help | h | \?)
            cmdOpts=
        ;;
        import)
            cmdOpts="--auto-props --no-auto-props $mOpts $qOpts $nOpts 		         --no-ignore --editor-cmd $pOpts --force"
        ;;
        info)
            cmdOpts="$pOpts $rOpts --targets -R --recursive --depth                          --incremental --xml $cOpts"
        ;;
        list | ls)
            cmdOpts="$rOpts -v --verbose -R --recursive $pOpts                          --incremental --xml --depth --include-externals"
        ;;
        lock)
            cmdOpts="-m --message -F --file --encoding --force-log                          --targets --force $pOpts"
        ;;
        log)
            cmdOpts="$rOpts -v --verbose --targets $pOpts --stop-on-copy 		         --incremental --xml $qOpts -l --limit -c --change                          $gOpts --with-all-revprops --with-revprop --depth 		         --diff --diff-cmd -x --extensions --internal-diff 		         --with-no-revprops --search --search-and"
        ;;
        merge)
            cmdOpts="$rOpts $nOpts $qOpts --force --dry-run --diff3-cmd 		         $pOpts --ignore-ancestry -c --change -x --extensions                          --record-only --accept --reintegrate 		         --allow-mixed-revisions -v --verbose"
        ;;
        mergeinfo)
            cmdOpts="$rOpts $pOpts --depth --show-revs -R --recursive"
        ;;
        mkdir)
            cmdOpts="$mOpts $qOpts --editor-cmd $pOpts --parents"
        ;;
        move | mv | rename | ren)
            cmdOpts="$mOpts $rOpts $qOpts --force --editor-cmd $pOpts                          --parents --allow-mixed-revisions"
        ;;
        patch)
            cmdOpts="$qOpts $pOpts --dry-run --ignore-whitespace 			--reverse-diff --strip"
        ;;
        propdel | pdel | pd)
            cmdOpts="$qOpts -R --recursive $rOpts $pOpts $cOpts                          --depth";
            [[ -n $isRevProp || ! -n $prop ]] && cmdOpts="$cmdOpts --revprop"
        ;;
        propedit | pedit | pe)
            cmdOpts="--editor-cmd $pOpts $mOpts --force";
            [[ -n $isRevProp || ! -n $prop ]] && cmdOpts="$cmdOpts --revprop $rOpts"
        ;;
        propget | pget | pg)
            cmdOpts="-v --verbose -R --recursive $rOpts --strict 		         $pOpts $cOpts --depth --xml --show-inherited-props";
            [[ -n $isRevProp || ! -n $prop ]] && cmdOpts="$cmdOpts --revprop"
        ;;
        proplist | plist | pl)
            cmdOpts="-v --verbose -R --recursive $rOpts --revprop $qOpts 		         $pOpts $cOpts --depth --xml --show-inherited-props"
        ;;
        propset | pset | ps)
            cmdOpts="$qOpts --targets -R --recursive 		         --encoding $pOpts --force $cOpts --depth";
            [[ -n $isRevProp || ! -n $prop ]] && cmdOpts="$cmdOpts --revprop $rOpts";
            [[ -n $val ]] || cmdOpts="$cmdOpts -F --file"
        ;;
        relocate)
            cmdOpts="--ignore-externals $pOpts"
        ;;
        resolve)
            cmdOpts="--targets -R --recursive $qOpts $pOpts --accept                          --depth"
        ;;
        resolved)
            cmdOpts="--targets -R --recursive $qOpts $pOpts --depth"
        ;;
        revert)
            cmdOpts="--targets -R --recursive $qOpts $cOpts                          --depth $pOpts"
        ;;
        status | stat | st)
            cmdOpts="-u --show-updates -v --verbose $nOpts $qOpts $pOpts 		         --no-ignore --ignore-externals --incremental --xml                          $cOpts"
        ;;
        switch | sw)
            cmdOpts="--relocate $rOpts $nOpts $qOpts $pOpts --diff3-cmd                          --force --accept --ignore-externals --set-depth 		         --ignore-ancestry"
        ;;
        unlock)
            cmdOpts="--targets --force $pOpts"
        ;;
        update | up)
            cmdOpts="$rOpts $nOpts $qOpts $pOpts --diff3-cmd                          --ignore-externals --force --accept $cOpts                          --parents --editor-cmd --set-depth"
        ;;
        upgrade)
            cmdOpts="$qOpts $pOpts"
        ;;
        *)

        ;;
    esac;
    [[ "$cmd" != "--version" ]] && cmdOpts="$cmdOpts $helpOpts";
    cmdOpts="$cmdOpts --config-dir --config-option";
    if [[ $acceptOpt == @(edit|launch) ]]; then
        cmdOpts=${cmdOpts/ --non-interactive / };
    fi;
    for opt in $options;
    do
        local optBase;
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -v)
                cmdOpts=${cmdOpts/ --verbose / }
            ;;
            --verbose)
                cmdOpts=${cmdOpts/ -v / }
            ;;
            -N)
                cmdOpts=${cmdOpts/ --non-recursive / }
            ;;
            --non-recursive)
                cmdOpts=${cmdOpts/ -N / }
            ;;
            -R)
                cmdOpts=${cmdOpts/ --recursive / }
            ;;
            --recursive)
                cmdOpts=${cmdOpts/ -R / }
            ;;
            -x)
                cmdOpts=${cmdOpts/ --extensions / }
            ;;
            --extensions)
                cmdOpts=${cmdOpts/ -x / }
            ;;
            -q)
                cmdOpts=${cmdOpts/ --quiet / }
            ;;
            --quiet)
                cmdOpts=${cmdOpts/ -q / }
            ;;
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -l)
                cmdOpts=${cmdOpts/ --limit / }
            ;;
            --limit)
                cmdOpts=${cmdOpts/ -l / }
            ;;
            -r)
                cmdOpts=${cmdOpts/ --revision / }
            ;;
            --revision)
                cmdOpts=${cmdOpts/ -r / }
            ;;
            -c)
                cmdOpts=${cmdOpts/ --change / }
            ;;
            --change)
                cmdOpts=${cmdOpts/ -c / }
            ;;
            --auto-props)
                cmdOpts=${cmdOpts/ --no-auto-props / }
            ;;
            --no-auto-props)
                cmdOpts=${cmdOpts/ --auto-props / }
            ;;
            -g)
                cmdOpts=${cmdOpts/ --use-merge-history / }
            ;;
            --use-merge-history)
                cmdOpts=${cmdOpts/ -g / }
            ;;
            -m | --message | -F | --file)
                cmdOpts=${cmdOpts/ --message / };
                cmdOpts=${cmdOpts/ -m / };
                cmdOpts=${cmdOpts/ --file / };
                cmdOpts=${cmdOpts/ -F / }
            ;;
        esac;
        if [ $isHelpCmd ]; then
            cmdOpts=${cmdOpts/ -h / };
            cmdOpts=${cmdOpts/ --help / };
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_svn_grcut () 
{ 
    local re=$1 line= old_IFS;
    old_IFS="$IFS";
    IFS='
';
    while read -r line; do
        [[ ! -n $re || $line == $re ]] && echo "${line/????????/}";
    done;
    IFS="$old_IFS"
}
_svn_info () 
{ 
    local what=$1 line=;
    LANG=C LC_MESSAGES=C svn info --non-interactive 2> /dev/null | while read line; do
        [[ $line == *"$what: "* ]] && echo ${line#*: };
    done
}
_svn_lls () 
{ 
    local opt=$1 f=;
    shift;
    for f in "$@";
    do
        if [[ $opt == @(dir|all) && -d "$f" ]]; then
            echo "$f/";
        else
            if [[ $opt == @(file|all) ]]; then
                local dn= fn="$f";
                [[ "$f" == */* ]] && dn=${f%\/*}/ fn=${f##*\/};
                [ -f "${dn}.svn/text-base/${fn}.svn-base" ] && echo "$f";
            fi;
        fi;
    done
}
_svn_read_hashfile () 
{ 
    local tkey=$1 key= val=;
    while true; do
        read tag len;
        [ $tag = 'END' ] && break;
        [ $tag != 'K' ] && { 
            return
        };
        read -r -n $len key;
        read;
        read tag len;
        [ $tag != 'V' ] && { 
            return
        };
        read -r -n $len val;
        read;
        if [[ $key = $tkey ]]; then
            echo "$val";
            return;
        fi;
    done
}
_svnadmin () 
{ 
    local cur cmds cmdOpts optsParam opt helpCmds optBase i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='crashtest create deltify dump freeze help hotcopy list-dblogs \
	      list-unused-dblogs load lock lslocks lstxns pack recover rmlocks \
	      rmtxns setlog setrevprop setuuid unlock upgrade verify --version';
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    optsParam="-r|--revision|--parent-dir|--fs-type|-M|--memory-cache-size";
    optsParam="$optsParam|-F|--file";
    helpCmds='help|--help|h|\?';
    if [[ ${COMP_WORDS[1]} != @($helpCmds) ]] && [[ "$cur" != -* ]] || [[ ${COMP_WORDS[COMP_CWORD-1]} == @($optsParam) ]]; then
        return 0;
    fi;
    cmdOpts=;
    case ${COMP_WORDS[1]} in 
        create)
            cmdOpts="--bdb-txn-nosync --bdb-log-keep --config-dir 		         --fs-type --pre-1.4-compatible --pre-1.5-compatible 		         --pre-1.6-compatible --compatible-version"
        ;;
        deltify)
            cmdOpts="-r --revision -q --quiet"
        ;;
        dump)
            cmdOpts="-r --revision --incremental -q --quiet --deltas 		         -M --memory-cache-size"
        ;;
        freeze)
            cmdOpts="-F --file"
        ;;
        help | h | \?)
            cmdOpts="$cmds"
        ;;
        hotcopy)
            cmdOpts="--clean-logs"
        ;;
        load)
            cmdOpts="--ignore-uuid --force-uuid --parent-dir -q --quiet 		         --use-pre-commit-hook --use-post-commit-hook 		         --bypass-prop-validation -M --memory-cache-size"
        ;;
        lock | unlock)
            cmdOpts="--bypass-hooks"
        ;;
        recover)
            cmdOpts="--wait"
        ;;
        rmtxns)
            cmdOpts="-q --quiet"
        ;;
        setlog)
            cmdOpts="-r --revision --bypass-hooks"
        ;;
        setrevprop)
            cmdOpts="-r --revision --use-pre-revprop-change-hook 		         --use-post-revprop-change-hook"
        ;;
        verify)
            cmdOpts="-r --revision -q --quiet"
        ;;
        *)

        ;;
    esac;
    cmdOpts="$cmdOpts --help -h";
    for ((i=2; i<=$COMP_CWORD-1; ++i ))
    do
        opt=${COMP_WORDS[$i]};
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -q)
                cmdOpts=${cmdOpts/ --quiet / }
            ;;
            --quiet)
                cmdOpts=${cmdOpts/ -q / }
            ;;
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -r)
                cmdOpts=${cmdOpts/ --revision / }
            ;;
            --revision)
                cmdOpts=${cmdOpts/ -r / }
            ;;
            -F)
                cmdOpts=${cmdOpts/ --file / }
            ;;
            --file)
                cmdOpts=${cmdOpts/ -F / }
            ;;
            -M)
                cmdOpts=${cmdOpts/ --memory-cache-size / }
            ;;
            --memory-cache-size)
                cmdOpts=${cmdOpts/ --M / }
            ;;
        esac;
        if [[ $opt == @($optsParam) ]]; then
            ((++i));
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_svndumpfilter () 
{ 
    local cur cmds cmdOpts optsParam opt helpCmds optBase i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='exclude help include --version';
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    optsParam="--targets";
    helpCmds='help|--help|h|\?';
    if [[ ${COMP_WORDS[1]} != @($helpCmds) ]] && [[ "$cur" != -* ]] || [[ ${COMP_WORDS[COMP_CWORD-1]} == @($optsParam) ]]; then
        return 0;
    fi;
    cmdOpts=;
    case ${COMP_WORDS[1]} in 
        exclude | include)
            cmdOpts="--drop-empty-revs --renumber-revs
		         --skip-missing-merge-sources --targets
		         --preserve-revprops --quiet"
        ;;
        help | h | \?)
            cmdOpts="$cmds"
        ;;
        *)

        ;;
    esac;
    cmdOpts="$cmdOpts --help -h";
    for ((i=2; i<=$COMP_CWORD-1; ++i ))
    do
        opt=${COMP_WORDS[$i]};
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
        esac;
        if [[ $opt == @($optsParam) ]]; then
            ((++i));
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_svnlook () 
{ 
    local cur cmds cmdOpts optsParam opt helpCmds optBase i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='author cat changed date diff dirs-changed help history info \
	      lock log propget proplist tree uuid youngest --version';
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    optsParam="-r|--revision|-t|--transaction|-l|--limit|-x|--extensions";
    helpCmds='help|--help|h|\?';
    if [[ ${COMP_WORDS[1]} != @($helpCmds) ]] && [[ "$cur" != -* ]] || [[ ${COMP_WORDS[COMP_CWORD-1]} == @($optsParam) ]]; then
        return 0;
    fi;
    cmdOpts=;
    case ${COMP_WORDS[1]} in 
        author)
            cmdOpts="-r --revision -t --transaction"
        ;;
        cat)
            cmdOpts="-r --revision -t --transaction"
        ;;
        changed)
            cmdOpts="-r --revision -t --transaction --copy-info"
        ;;
        date)
            cmdOpts="-r --revision -t --transaction"
        ;;
        diff)
            cmdOpts="-r --revision -t --transaction --diff-copy-from 		         --no-diff-added --no-diff-deleted -x --extensions"
        ;;
        dirs-changed)
            cmdOpts="-r --revision -t --transaction"
        ;;
        help | h | \?)
            cmdOpts="$cmds"
        ;;
        history)
            cmdOpts="-r --revision -l --limit --show-ids"
        ;;
        info)
            cmdOpts="-r --revision -t --transaction"
        ;;
        lock)
            cmdOpts=
        ;;
        log)
            cmdOpts="-r --revision -t --transaction"
        ;;
        propget | pget | pg)
            cmdOpts="-r --revision -t --transaction --revprop"
        ;;
        proplist | plist | pl)
            cmdOpts="-r --revision -t --transaction --revprop -v --verbose --xml"
        ;;
        tree)
            cmdOpts="-r --revision -t --transaction --full-paths -N --non-recursive --show-ids"
        ;;
        uuid)
            cmdOpts=
        ;;
        youngest)
            cmdOpts=
        ;;
        *)

        ;;
    esac;
    cmdOpts="$cmdOpts --help -h";
    for ((i=2; i<=$COMP_CWORD-1; ++i ))
    do
        opt=${COMP_WORDS[$i]};
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -N)
                cmdOpts=${cmdOpts/ --non-recursive / }
            ;;
            --non-recursive)
                cmdOpts=${cmdOpts/ -N / }
            ;;
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -l)
                cmdOpts=${cmdOpts/ --limit / }
            ;;
            --limit)
                cmdOpts=${cmdOpts/ -l / }
            ;;
            -r)
                cmdOpts=${cmdOpts/ --revision / }
            ;;
            --revision)
                cmdOpts=${cmdOpts/ -r / }
            ;;
            -t)
                cmdOpts=${cmdOpts/ --transaction / }
            ;;
            --transaction)
                cmdOpts=${cmdOpts/ -t / }
            ;;
            -v)
                cmdOpts=${cmdOpts/ --verbose / }
            ;;
            --verbose)
                cmdOpts=${cmdOpts/ -v / }
            ;;
            -x)
                cmdOpts=${cmdOpts/ --extensions / }
            ;;
            --extensions)
                cmdOpts=${cmdOpts/ -x / }
            ;;
        esac;
        if [[ $opt == @($optsParam) ]]; then
            ((++i));
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_svnsync () 
{ 
    local cur cmds cmdOpts optsParam opt helpCmds optBase i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='copy-revprops help info initialize synchronize --version';
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    optsParam="--config-dir|--config-option|--source-username|--source-password";
    optsParam="$optsParam|--sync-username|--sync-password";
    helpCmds='help|--help|h|\?';
    if [[ ${COMP_WORDS[1]} != @($helpCmds) ]] && [[ "$cur" != -* ]] || [[ ${COMP_WORDS[COMP_CWORD-1]} == @($optsParam) ]]; then
        return 0;
    fi;
    cmdOpts=;
    case ${COMP_WORDS[1]} in 
        copy-revprops | initialize | init | synchronize | sync)
            cmdOpts="--non-interactive --no-auth-cache --trust-server-cert 		         --source-username --source-password --sync-username 		         --sync-password --config-dir --config-option -q --quiet"
        ;;
        help | h | \?)
            cmdOpts="$cmds"
        ;;
        info)
            cmdOpts="--non-interactive --no-auth-cache --trust-server-cert 		         --source-username --source-password --sync-username 		         --sync-password --config-dir --config-option"
        ;;
        *)

        ;;
    esac;
    cmdOpts="$cmdOpts --help -h";
    for ((i=2; i<=$COMP_CWORD-1; ++i ))
    do
        opt=${COMP_WORDS[$i]};
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -q)
                cmdOpts=${cmdOpts/ --quiet / }
            ;;
            --quiet)
                cmdOpts=${cmdOpts/ -q / }
            ;;
        esac;
        if [[ $opt == @($optsParam) ]]; then
            ((++i));
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_svnversion () 
{ 
    local cmdOpts=" -n --no-newline -c --committed -h --help --version ";
    local cur=${COMP_WORDS[COMP_CWORD]};
    COMPREPLY=();
    local options= wcpath= trailurl= last='none' stat= opt= i=-1 isCur=;
    for opt in ${COMP_WORDS[@]};
    do
        [[ $i -eq $COMP_CWORD ]] && stat=$last;
        let i++;
        isCur=;
        [[ $i -eq $COMP_CWORD ]] && isCur=1;
        if [ $last = 'none' ]; then
            last='first';
            continue;
        fi;
        if [[ $last != 'arg' && $opt == -* ]]; then
            if [[ $opt = '--' && ! -n $isCur ]]; then
                last='arg';
            else
                options="$options $opt ";
                last='opt';
            fi;
            continue;
        fi;
        if [[ $opt != -* ]]; then
            last='arg';
            if [[ ! -n $wcpath ]]; then
                wcpath=$opt;
            else
                if [[ ! -n $trailurl ]]; then
                    trailurl=$opt;
                fi;
            fi;
        fi;
    done;
    [[ -n $stat ]] || stat=$last;
    if [[ $cur != -* || $stat = 'arg' ]]; then
        [[ -n $wcpath && -n $trailurl ]] && COMPREPLY=('');
        return 0;
    fi;
    for opt in $options;
    do
        cmdOpts=${cmdOpts/ $opt / };
        case $opt in 
            -n)
                cmdOpts=${cmdOpts/ --no-newline / }
            ;;
            --no-newline)
                cmdOpts=${cmdOpts/ -n / }
            ;;
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -c)
                cmdOpts=${cmdOpts/ --committed / }
            ;;
            --committed)
                cmdOpts=${cmdOpts/ -c / }
            ;;
        esac;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_sysvdirs () 
{ 
    sysvdirs=();
    [[ -d /etc/rc.d/init.d ]] && sysvdirs+=(/etc/rc.d/init.d);
    [[ -d /etc/init.d ]] && sysvdirs+=(/etc/init.d);
    [[ -f /etc/slackware-version ]] && sysvdirs=(/etc/rc.d)
}
_terms () 
{ 
    COMPREPLY+=($( compgen -W         "$( sed -ne 's/^\([^[:space:]#|]\{2,\}\)|.*/\1/p' /etc/termcap             2>/dev/null )" -- "$cur" ));
    COMPREPLY+=($( compgen -W "$( { toe -a 2>/dev/null || toe 2>/dev/null; }         | awk '{ print $1 }' | sort -u )" -- "$cur" ))
}
_tilde () 
{ 
    local result=0;
    if [[ $1 == \~* && $1 != */* ]]; then
        COMPREPLY=($( compgen -P '~' -u "${1#\~}" ));
        result=${#COMPREPLY[@]};
        [[ $result -gt 0 ]] && compopt -o filenames 2> /dev/null;
    fi;
    return $result
}
_ufw () 
{ 
    cur=${COMP_WORDS[COMP_CWORD]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($( compgen -W "$(_ufw_commands)" $cur ));
    else
        if [ $COMP_CWORD -eq 2 ]; then
            case "$prev" in 
                app)
                    COMPREPLY=($( compgen -W "$(_ufw_app_commands)" $cur ))
                ;;
                status)
                    COMPREPLY=($( compgen -W "$(_ufw_status_commands)" $cur ))
                ;;
                delete)
                    COMPREPLY=($( compgen -W "$(_ufw_rule_commands)" $cur ))
                ;;
                logging)
                    COMPREPLY=($( compgen -W "$(_ufw_logging_commands)" $cur ))
                ;;
                show)
                    COMPREPLY=($( compgen -W "$(_ufw_show_commands)" $cur ))
                ;;
                default)
                    COMPREPLY=($( compgen -W "$(_ufw_default_commands)" $cur ))
                ;;
            esac;
        fi;
    fi
}
_ufw_app_commands () 
{ 
    ufw --help | sed -e '1,/^Application profile commands:/d' -e '/^ [^ ]/!d' -e 's/[ \t]\+app[ \t]\+\([a-z|]\+\)[ \t]\+.*/\1/g'
}
_ufw_commands () 
{ 
    commands=$(ufw --help | sed -e '1,/^Commands:/d' -e '/^Application profile commands:/Q' -e 's/^[ \t]\+\([a-z|]\+\)[ \t]\+.*/\1/g' -e 's/|/ /g' | uniq);
    echo "$commands app"
}
_ufw_default_commands () 
{ 
    echo "allow deny reject"
}
_ufw_logging_commands () 
{ 
    echo "off on low medium high full"
}
_ufw_rule_commands () 
{ 
    echo "`_ufw_default_commands` limit"
}
_ufw_show_commands () 
{ 
    echo "raw"
}
_ufw_status_commands () 
{ 
    echo "numbered verbose"
}
_uids () 
{ 
    if type getent &> /dev/null; then
        COMPREPLY=($( compgen -W '$( getent passwd | cut -d: -f3 )' -- "$cur" ));
    else
        if type perl &> /dev/null; then
            COMPREPLY=($( compgen -W '$( perl -e '"'"'while (($uid) = (getpwent)[2]) { print $uid . "\n" }'"'"' )' -- "$cur" ));
        else
            COMPREPLY=($( compgen -W '$( cut -d: -f3 /etc/passwd )' -- "$cur" ));
        fi;
    fi
}
_update_initramfs () 
{ 
    local cur prev valid_options;
    cur=$(_get_cword);
    prev=${COMP_WORDS[COMP_CWORD-1]};
    if [[ "$prev" == '-k' ]]; then
        _kernel_versions;
        COMPREPLY=($( compgen -W '${COMPREPLY[@]} all' -- "$cur" ));
        return;
    fi;
    valid_options=$( update-initramfs -h 2>&1 | 		sed -e '/^ -/!d;s/^ \(-\w\+\).*/\1/' );
    COMPREPLY=($( compgen -W "$valid_options" -- $cur ))
}
_upstart_events () 
{ 
    ( cd /etc/init && egrep --color=auto '^[[:space:]]*emits ' *.conf | cut -d: -f2- | sed 's/^[[:space:]]*emits //g' | tr ' ' '\n' | awk '{print $NF}' | grep --color=auto -v ^$ | sort -u )
}
_upstart_initctl () 
{ 
    _get_comp_words_by_ref cur prev;
    COMPREPLY=();
    case "$prev" in 
        start)
            COMPREPLY=($(compgen -W "-n --no-wait $(_upstart_startable_jobs)" -- ${cur}));
            return 0
        ;;
        stop)
            COMPREPLY=($(compgen -W "-n --no-wait $(_upstart_stoppable_jobs)" -- ${cur}));
            return 0
        ;;
        emit)
            COMPREPLY=($(compgen -W "-n --no-wait $(_upstart_events)" -- ${cur}));
            return 0
        ;;
        -i | --ignore-events)
            for cmd in check-config;
            do
                cwords=${COMP_WORDS[@]##};
                filtered_cwords=${COMP_WORDS[@]##${cmd}};
                if [ "$filtered_cwords" != "$cwords" ]; then
                    COMPREPLY=($(compgen -W "$(_upstart_jobs)" -- ${cur}));
                    return 0;
                fi;
            done
        ;;
        -e | --enumerate)
            for cmd in show-config;
            do
                cwords=${COMP_WORDS[@]##};
                filtered_cwords=${COMP_WORDS[@]##${cmd}};
                if [ "$filtered_cwords" != "$cwords" ]; then
                    COMPREPLY=($(compgen -W "$(_upstart_jobs)" -- ${cur}));
                    return 0;
                fi;
            done
        ;;
        reload | restart)
            COMPREPLY=($(compgen -W "-n --no-wait $(_upstart_stoppable_jobs)" -- ${cur}));
            return 0
        ;;
        status)
            COMPREPLY=($(compgen -W "$(_upstart_jobs)" -- ${cur}));
            return 0
        ;;
        check-config)
            COMPREPLY=($(compgen -W "-w --warn -i --ignore-events= $(_upstart_jobs)" -- ${cur}));
            return 0
        ;;
        show-config)
            COMPREPLY=($(compgen -W "-e --enumerate $(_upstart_jobs)" -- ${cur}));
            return 0
        ;;
        -n | --no-wait)
            for cmd in start stop restart emit;
            do
                cwords=${COMP_WORDS[@]##};
                filtered_cwords=${COMP_WORDS[@]##${cmd}};
                if [ "$filtered_cwords" != "$cwords" ]; then
                    case "$cmd" in 
                        start)
                            COMPREPLY=($(compgen -W "$(_upstart_startable_jobs)" -- ${cur}))
                        ;;
                        stop)
                            COMPREPLY=($(compgen -W "$(_upstart_stoppable_jobs)" -- ${cur}))
                        ;;
                        restart)
                            COMPREPLY=($(compgen -W "$(_upstart_stoppable_jobs)" -- ${cur}))
                        ;;
                        emit)
                            COMPREPLY=($(compgen -W "$(_upstart_events)" -- ${cur}))
                        ;;
                    esac;
                    return 0;
                fi;
            done
        ;;
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=";
    cmds=$(initctl help|grep "^  [^ ]"|awk '{print $1}');
    COMPREPLY=($(compgen -W "${opts} ${cmds}" -- ${cur}))
}
_upstart_jobs () 
{ 
    initctl list | awk '{print $1}' | sort -u
}
_upstart_reload () 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_stoppable_jobs)" -- ${cur}));
    return 0
}
_upstart_restart () 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=         -n --no-wait";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_stoppable_jobs)" -- ${cur}));
    return 0
}
_upstart_start () 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=         -n --no-wait";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_startable_jobs)" -- ${cur}));
    return 0
}
_upstart_startable_jobs () 
{ 
    initctl list | cut -d\, -f1 | awk '$2 == "stop/waiting" {print $1}'
}
_upstart_status () 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q -d --detail -e --enumerate --quiet -v --verbose --session --system --dest=";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_jobs)" -- ${cur}));
    return 0
}
_upstart_stop () 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=         -n --no-wait";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_stoppable_jobs)" -- ${cur}));
    return 0
}
_upstart_stoppable_jobs () 
{ 
    initctl list | cut -d\, -f1 | awk '$2 == "start/running" {print $1}'
}
_upvar () 
{ 
    if unset -v "$1"; then
        if (( $# == 2 )); then
            eval $1=\"\$2\";
        else
            eval $1=\(\"\${@:2}\"\);
        fi;
    fi
}
_upvars () 
{ 
    if ! (( $# )); then
        echo "${FUNCNAME[0]}: usage: ${FUNCNAME[0]} [-v varname" "value] | [-aN varname [value ...]] ..." 1>&2;
        return 2;
    fi;
    while (( $# )); do
        case $1 in 
            -a*)
                [[ -n ${1#-a} ]] || { 
                    echo "bash: ${FUNCNAME[0]}: \`$1': missing" "number specifier" 1>&2;
                    return 1
                };
                printf %d "${1#-a}" &> /dev/null || { 
                    echo "bash:" "${FUNCNAME[0]}: \`$1': invalid number specifier" 1>&2;
                    return 1
                };
                [[ -n "$2" ]] && unset -v "$2" && eval $2=\(\"\${@:3:${1#-a}}\"\) && shift $((${1#-a} + 2)) || { 
                    echo "bash: ${FUNCNAME[0]}:" "\`$1${2+ }$2': missing argument(s)" 1>&2;
                    return 1
                }
            ;;
            -v)
                [[ -n "$2" ]] && unset -v "$2" && eval $2=\"\$3\" && shift 3 || { 
                    echo "bash: ${FUNCNAME[0]}: $1: missing" "argument(s)" 1>&2;
                    return 1
                }
            ;;
            *)
                echo "bash: ${FUNCNAME[0]}: $1: invalid option" 1>&2;
                return 1
            ;;
        esac;
    done
}
_usb_ids () 
{ 
    COMPREPLY+=($( compgen -W         "$( PATH="$PATH:/sbin" lsusb | awk '{print $6}' )" -- "$cur" ))
}
_user_at_host () 
{ 
    local cur prev words cword;
    _init_completion -n : || return;
    if [[ $cur == *@* ]]; then
        _known_hosts_real "$cur";
    else
        COMPREPLY=($( compgen -u -- "$cur" ));
    fi;
    return 0
}
_usergroup () 
{ 
    if [[ $cur = *\\\\* || $cur = *:*:* ]]; then
        return;
    else
        if [[ $cur = *\\:* ]]; then
            local prefix;
            prefix=${cur%%*([^:])};
            prefix=${prefix//\\};
            local mycur="${cur#*[:]}";
            if [[ $1 == -u ]]; then
                _allowed_groups "$mycur";
            else
                local IFS='
';
                COMPREPLY=($( compgen -g -- "$mycur" ));
            fi;
            COMPREPLY=($( compgen -P "$prefix" -W "${COMPREPLY[@]}" ));
        else
            if [[ $cur = *:* ]]; then
                local mycur="${cur#*:}";
                if [[ $1 == -u ]]; then
                    _allowed_groups "$mycur";
                else
                    local IFS='
';
                    COMPREPLY=($( compgen -g -- "$mycur" ));
                fi;
            else
                if [[ $1 == -u ]]; then
                    _allowed_users "$cur";
                else
                    local IFS='
';
                    COMPREPLY=($( compgen -u -- "$cur" ));
                fi;
            fi;
        fi;
    fi
}
_userland () 
{ 
    local userland=$( uname -s );
    [[ $userland == @(Linux|GNU/*) ]] && userland=GNU;
    [[ $userland == $1 ]]
}
_variables () 
{ 
    if [[ $cur =~ ^(\$\{?)([A-Za-z0-9_]*)$ ]]; then
        [[ $cur == *{* ]] && local suffix=} || local suffix=;
        COMPREPLY+=($( compgen -P ${BASH_REMATCH[1]} -S "$suffix" -v --             "${BASH_REMATCH[2]}" ));
        return 0;
    fi;
    return 1
}
_xfunc () 
{ 
    set -- "$@";
    local srcfile=$1;
    shift;
    declare -F $1 &> /dev/null || { 
        local compdir=./completions;
        [[ $BASH_SOURCE == */* ]] && compdir="${BASH_SOURCE%/*}/completions";
        . "$compdir/$srcfile"
    };
    "$@"
}
_xinetd_services () 
{ 
    local xinetddir=/etc/xinetd.d;
    if [[ -d $xinetddir ]]; then
        local restore_nullglob=$(shopt -p nullglob);
        shopt -s nullglob;
        local -a svcs=($( printf '%s\n' $xinetddir/!($_backup_glob) ));
        $restore_nullglob;
        COMPREPLY+=($( compgen -W '${svcs[@]#$xinetddir/}' -- "$cur" ));
    fi
}
_zeitgeist_daemon () 
{ 
    local cur=${COMP_WORDS[COMP_CWORD]};
    COMPREPLY=($(compgen -W "`zeitgeist-daemon --shell-completion`" -- $cur))
}
command_not_found_handle () 
{ 
    if [ -x /usr/lib/command-not-found ]; then
        /usr/lib/command-not-found -- "$1";
        return $?;
    else
        if [ -x /usr/share/command-not-found/command-not-found ]; then
            /usr/share/command-not-found/command-not-found -- "$1";
            return $?;
        else
            printf "%s: command not found\n" "$1" 1>&2;
            return 127;
        fi;
    fi
}
dequote () 
{ 
    eval printf %s "$1" 2> /dev/null
}
in_array () 
{ 
    local i;
    for i in "${@:2}";
    do
        [[ $1 = "$i" ]] && return;
    done
}
quote () 
{ 
    local quoted=${1//\'/\'\\\'\'};
    printf "'%s'" "$quoted"
}
quote_readline () 
{ 
    local quoted;
    _quote_readline_by_ref "$1" ret;
    printf %s "$ret"
}
